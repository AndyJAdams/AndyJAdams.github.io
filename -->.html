<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>--></title>
	<style type="text/css">
		body, html{ 
			margin: 0; 
			background-color: #DDD;
			position: fixed;
		}
		canvas{
            touch-action: none;
		}
	</style>
</head>
<body id='body'>
	<canvas id='canvas'></canvas>
	
	<script>
    //Global Variables
    var blockWidth =40;
    var half = blockWidth/2;
    var qtr = blockWidth/4;
    var eth = blockWidth/8;
    var sxth = blockWidth/16;

    var blockDamp = 10;
    var cb = undefined;
        
	var canvas = document.getElementById('canvas');	
	function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	}

    var gridWidth = Math.floor((innerWidth*0.9)/blockWidth);
    var gridHeight = Math.floor((innerHeight*0.9)/blockWidth);
	scaleCanvas();
	var ctx = canvas.getContext('2d');

	function lerp (start, end, amt){
  		return (1-amt)*start+amt*end;
	}
        
    function Block(x,y,type,locked, r, c){
        this.ss = "#333";
        this.x = x;
        this.y = y;
        this.dx = this.x;
        this.dy = this.y;
        this.type = type;
        this.locked = locked;
        this.r = r;
        this.c = c;

        this.update = function(){
            // if(this.x != this.dx){
            //     if(this.x < this.dx && (this.dx-this.x) > 0.01){
            //         this.x += (this.dx-this.x)/blockDamp;
            //     } else if(this.x > this.dx && (this.x-this.dx) > 0.01){
            //         this.x -= (this.x-this.dx)/blockDamp;
            //     }
            // }
            this.draw();
        }
        
        this.draw = function(){
            ctx.strokeStyle = this.ss;
            ctx.lineWidth = 5;
            if(this.type > -1){
                ctx.beginPath();
                ctx.moveTo(this.x-half,this.y-half);
                ctx.lineTo(this.x+half,this.y-half);
                ctx.lineTo(this.x+half,this.y+half);
                ctx.lineTo(this.x-half,this.y+half);
                ctx.closePath();
                ctx.stroke();
                if(this.locked){
                    ctx.fillRect(this.x-half+sxth,this.y-half+sxth,eth,eth);
                    ctx.fillRect(this.x+half-sxth-eth,this.y+half-sxth-eth,eth,eth);
                    ctx.fillRect(this.x-half+sxth,this.y+half-sxth-eth,eth,eth);
                    ctx.fillRect(this.x+half-sxth-eth,this.y-half+sxth,eth,eth);
                    
                    
                }
            }
            
            ctx.lineWidth = 10;
            switch(this.type){
                case 0: //Straight horz
                    ctx.beginPath();
                    ctx.moveTo(this.x-half,this.y);
                    ctx.lineTo(this.x+half,this.y);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                case 1: //Straight vert
                    ctx.beginPath();
                    ctx.moveTo(this.x,this.y-half);
                    ctx.lineTo(this.x,this.y+half);
                    ctx.closePath();
                    ctx.stroke();
                    break;
                case 2: //90 left-up
                    ctx.beginPath();
                    ctx.moveTo(this.x-half,this.y);
                    ctx.lineTo(this.x,this.y);
                    ctx.lineTo(this.x,this.y-half);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                case 3: //90 left-down
                    ctx.beginPath();
                    ctx.moveTo(this.x-half,this.y);
                    ctx.lineTo(this.x,this.y);
                    ctx.lineTo(this.x,this.y+half);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                case 4: //90 right-up
                    ctx.beginPath();
                    ctx.moveTo(this.x+half,this.y);
                    ctx.lineTo(this.x,this.y);
                    ctx.lineTo(this.x,this.y-half);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                case 5: //90 right-down
                    ctx.beginPath();
                    ctx.moveTo(this.x+half,this.y);
                    ctx.lineTo(this.x,this.y);
                    ctx.lineTo(this.x,this.y+half);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                case 6: //Blank
                    ctx.fillRect(this.x-qtr,this.y-qtr,half,half);
                    break;
                // case 7: //start left
                //     ctx.beginPath();
                //     ctx.moveTo(this.x-half, this.y);
                //     ctx.lineTo(this.x,this.y);
                //     ctx.stroke();
                //     ctx.closePath();
                //     ctx.fillRect(this.x-eth,this.y-eth,qtr,qtr);
                //     break;
                // case 8: //start right
                //     ctx.beginPath();
                //     ctx.moveTo(this.x+half, this.y);
                //     ctx.lineTo(this.x,this.y);
                //     ctx.stroke();
                //     ctx.closePath();
                //     ctx.fillRect(this.x-eth,this.y-eth,qtr,qtr);
                //     break;
                // case 9: //start up
                //     ctx.beginPath();
                //     ctx.moveTo(this.x, this.y-half);
                //     ctx.lineTo(this.x,this.y);
                //     ctx.stroke();
                //     ctx.closePath();
                //     ctx.fillRect(this.x-eth,this.y-eth,qtr,qtr);
                //     break;
                // case 10: //start down
                //     ctx.beginPath();
                //     ctx.moveTo(this.x, this.y+half);
                //     ctx.lineTo(this.x,this.y);
                //     ctx.stroke();
                //     ctx.closePath();
                //     ctx.fillRect(this.x-eth,this.y-eth,qtr,qtr);
                //     break;
                // case 11: //end left
                //     ctx.beginPath();
                //     ctx.moveTo(this.x-half, this.y);
                //     ctx.lineTo(this.x-qtr,this.y);
                //     ctx.stroke();
                //     ctx.closePath();
                //     ctx.fillRect(this.x-eth,this.y-eth,qtr,qtr);
                //     break;
                // case 12: //end right
                //     ctx.beginPath();
                //     ctx.moveTo(this.x+half, this.y);
                //     ctx.lineTo(this.x+qtr,this.y);
                //     ctx.stroke();
                //     ctx.closePath();
                //     ctx.fillRect(this.x-eth,this.y-eth,qtr,qtr);
                //     break;
                // case 13: //end up
                //     ctx.beginPath();
                //     ctx.moveTo(this.x, this.y-half);
                //     ctx.lineTo(this.x,this.y-qtr);
                //     ctx.stroke();
                //     ctx.closePath();
                //     ctx.fillRect(this.x-eth,this.y-eth,qtr,qtr);
                //     break;
                // case 14: //end down
                //     ctx.beginPath();
                //     ctx.moveTo(this.x, this.y+half);
                //     ctx.lineTo(this.x,this.y+qtr);
                //     ctx.stroke();
                //     ctx.closePath();
                //     ctx.fillRect(this.x-eth,this.y-eth,qtr,qtr);
                //     break;
                default:
                    break;
            }
        }
    }
    var blocks = [];
    buildGrid();

    function buildGrid(){
        var offsetX = (gridWidth-1)/2;
        var offsetY = (gridHeight-1)/2;
        for(var a = 0; a < gridHeight;a++){
            var row = [];
            for(var b = 0; b < gridWidth; b++){
                var randId = Math.floor(Math.random()*7);
                var nx = innerWidth/2 - ((b-offsetX)*blockWidth);
                var ny = innerHeight/2 - ((a-offsetY)*blockWidth);
                var newBlock = new Block(nx,ny, randId, false, b,a);
                row.push(newBlock);
            }
            blocks[a] = row;
        }
        
    }

    function ResetMap(){
        
        var gridWidth = Math.floor((innerWidth*0.9)/blockWidth);
        var gridHeight = Math.floor((innerHeight*0.9)/blockWidth);
        blocks = [];
        buildGrid();
    }

    function RandomizeGrid(){
        for(var r = 0; r < 7; r++){
            var rx = Math.floor(Math.random()*gridWidth);
            var ry = Math.floor(Math.random()*gridHeight);
            blocks[rx][ry].type = Math.floor(Math.random()*7);
        }
    }

    var ticker = 0;
	function animate(){
		window.requestAnimationFrame(animate);
		ctx.clearRect(0,0,innerWidth,innerHeight);
        for(var a = 0; a < gridHeight; a++){
            for(var b = 0; b < gridWidth; b++){
                if(blocks[a][b] != undefined){
                    if(blocks[a][b] == cb){
                        blocks[a][b].ss = "#F00";
                    } else {
                        blocks[a][b].ss = "#333";
                    }
                    blocks[a][b].update();
                } else {
                    console.log("Missing Block: " + a + "," + b);
                }
            }
        }
        ticker++;
        if(ticker >= 50){
            ResetMap();
            ticker = 0;
        }
	}

    function GetClosestBlock(gx,gy){
        for(var a = 0; a < gridHeight; a++){
            for(var b = 0; b < gridWidth; b++){
                if(blocks[a][b].x+half > gx && blocks[a][b].x-half < gx && blocks[a][b].y+half > gy && blocks[a][b].y-half < gy){
                    return blocks[a][b];
                }
            }
        }
    }

	var mx = 0; //Touch || Mouse initial input position on x
    var my = 0; //Touch || Mouse initial input position on y
    

	window.addEventListener('touchstart', function(evt){
        evt.preventDefault();
		mx = evt.changedTouches[0].pageX;
        my = evt.changedTouches[0].pageY; 
    }, false);
	
    window.addEventListener('touchmove', function(evt){
        evt.preventDefault();
    }, false);
	
    window.addEventListener('touchcancel', function(evt){
        evt.preventDefault();
    }, false);
	
	//User has removed finger... let's figure out the desired action here. 
    window.addEventListener('touchend', function(evt){
        evt.preventDefault();
    }, false);

    window.addEventListener('mousedown', function(evt){
    	evt.preventDefault();
        console.log(evt.pageX + "," + evt.pageY);
        cb = GetClosestBlock(evt.pageX, evt.pageY);
    },false);

    window.addEventListener('mousemove', function(evt){
    	evt.preventDefault();
    },false);

    window.addEventListener('mouseup', function(evt){
    	evt.preventDefault();
        cb = undefined;
    },false);

    window.addEventListener('resize', function(evt){
    	scaleCanvas();
        ResetMap();
    },false);

	animate();
	</script>
</body>
</html>