<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>SORTED</title>
	<style type="text/css">
		body{
            margin: 0;
            touch-action: none;
            position: fixed;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
        }
        canvas{
            touch-action: none;
            background-color: #222;
        }
	</style>
</head>
<body id='body'>
	<canvas id='canvas'></canvas>
	<script>
    var grid = {rows: 5,columns: 4};
    var dragSensitivity = 50;
    var palettes = [
    ['#97352D','#DDD9A8','#9BC1BC','#F5F9F0','#36C9C6'],
    ['#4E3D42','#6D6466','#9F9F92','#C9D5B5','#E3DBDB'],
    ['#F9FDF7','#8997B2','#465F5D','#ADC2BF','#392A30'],
    ['#202820','#389397','#C9F6FC','#4C4295','#D0A9B2'],
    ['#000000','#FFFFFC','#BEB7A4','#FF9125','#FF3F00'],
    ['#A5341C','#29335C','#F3A712','#86A16B','#C9F5F8'],
    ['#560510','#9D454A','#F5DBCB','#97967D','#A0D4A1']
    ];
    var DEBUG = false;

	var canvas = document.getElementById('canvas');
    var randPalette = Math.floor(Math.random()*palettes.length);
    var tileSize = {x:-1,y:-1};
    var tiles = [];
    var points = [];

    //DEBUG ONLY
    // grid.rows = Math.floor(Math.random()*5)+5;
    // grid.columns = Math.floor(Math.random()*5)+5;
    // if(window.innerHeight < window.innerWidth){
    //     grid.columns = grid.rows+1;
    // } else {
    //     grid.rows = grid.columns+1;
    // }
    //

    function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

        tileSize.x = innerWidth/grid.columns;
        tileSize.y = innerHeight/grid.rows;
        if(tiles.length < 1){
            buildGrid();
        }
        scaleGrid();
	}

	var ctx = canvas.getContext('2d');

    function Point(x,y,c,r){
        this.x = x; this.y = y; this.c = c; this.r = r;
    }

    function Tile(x,y,v,c,r){
        this.x = x; this.y = y; this.r = r; this.c = c; this.v = v;
        this.effected = false; this.dx = 0; this.dy = 0;
        this.draw = function(){
            ctx.fillStyle=palettes[randPalette][this.v];
            ctx.fillRect(this.x+this.dx, this.y+this.dy, tileSize.x+1, tileSize.y+1);

            if(DEBUG){
                ctx.fillStyle='#FFF';
                ctx.fillText(this.c+","+this.r,this.x+this.dx+4,this.y+this.dy+20);
                if(allCol.length > 0){
                    for(var i = 0; i < allCol.length; i++){
                        if(allCol[i] == this){
                            ctx.fillStyle='#000';
                            ctx.fillRect(this.x+tileSize.x/2-10+this.dx,this.y+tileSize.y/2-10+this.dy,20,20);
                        }
                    }
                }
                if(allRow.length > 0){
                    for(var i = 0; i < allRow.length; i++){
                        if(allRow[i] == this){
                            ctx.fillStyle='#000';
                            ctx.fillRect(this.x+tileSize.x/2-10+this.dx,this.y+tileSize.y/2-10+this.dy,20,20);
                        }
                    }
                }
            }

        }

        this.update = function(){
            ctx.fillStyle=palettes[randPalette][this.v];
            if(this.x+this.dx < 0){
                if(this.x+this.dx+(tileSize.x/2) < 0){
                    console.log("snapset left");
                    this.x += innerWidth;
                } else {
                    ctx.fillRect(innerWidth+(this.x+this.dx),this.y,tileSize.x+1,tileSize.y+1);
                }
            } else if(this.x+this.dx+tileSize.x > innerWidth){
                if(this.x+this.dx+(tileSize.x/2) > innerWidth){
                    console.log("snapset right");
                    this.x -= innerWidth;
                } else {
                    ctx.fillRect((this.x+this.dx)-innerWidth,this.y,tileSize.x+1,tileSize.y+1);
                }
            }

            if(this.y+this.dy-1 < 0){
                if(this.y+this.dy+(tileSize.y/2) < 0){
                    console.log("snapset up");
                    this.y += innerHeight;
                } else {
                    ctx.fillRect(this.x,innerHeight+(this.y+this.dy),tileSize.x+1,tileSize.y+1);
                }
            } else if(this.y+this.dy+tileSize.y > innerHeight){
                if(this.y+this.dy+(tileSize.y/2) > innerHeight){
                    console.log("snapset down");
                    this.y -= innerHeight;
                } else {
                    ctx.fillRect(this.x,(this.y+this.dy)-innerHeight,tileSize.x+1,tileSize.y+1);
                }
            }
            this.draw();

            //this.draw();
        }
    }

    function buildGrid(){
        tiles = [];
        points = [];
        for(var i = 0; i < grid.columns; i++){
            var row = [];
            var p_row = [];
            for(var j = 0; j < grid.rows; j++){
                var x = i*tileSize.x;
                var y = j*tileSize.y;
                var v = Math.floor(Math.random()*palettes[randPalette].length);
                row.push(new Tile(x,y,v,i,j));
                p_row.push(new Point(x,y,i,j));
            }
            tiles.push(row);
            points.push(p_row);
        }
    }

    function scaleGrid(){
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                tiles[i][j].x = i*tileSize.x;
                tiles[i][j].y = j*tileSize.y;
                points[i][j].x = i*tileSize.x;
                points[i][j].y = j*tileSize.y;
            }
        }
    }

    var collections = [];
    function makeCollections(){
        collections = [];
        for(var i = tiles.length-1; i > -1; i--){
            for(var j = tiles[i].length-1; j > -1; j--){
                var col = -1;
                var matches = [tiles[i][j]];
                //starting from the last tile we can check the right and down tiles for matches
                //right is I
                if(i+1 < tiles.length && tiles[i+1][j] != undefined){
                    if(tiles[i+1][j].v == tiles[i][j].v){
                        //We found a match. Check all the collections for the matching tile
                        for(var c = 0; c < collections.length; c++){
                            if(collections[c].includes(tiles[i+1][j])){
                                collections[c].unshift(tiles[i][j]);
                                col = c;
                                break;
                            }
                        }
                        if(col == -1){
                            matches.push(tiles[i+1][j]);
                        }
                    }
                }
                //down is j
                if(j+1 < tiles[i].length && tiles[i][j+1] != undefined){
                    if(tiles[i][j+1].v == tiles[i][j].v){
                        for(var c = 0; c < collections.length; c++){
                            if(collections[c].includes(tiles[i][j+1])){
                                if(col == -1){ //We didn't find a collection on the right
                                    collections[c].unshift(tiles[i][j]);
                                    if(matches.length > 1){
                                        collections[c].unshift(matches[1]);
                                        matches = [];
                                    }

                                    col = c;
                                } else {
                                    //So the right found a collection... and bottom found a collection
                                    if(col == c){
                                        //It's the same collection!
                                        collections[c].unshift(tiles[i][j]);
                                    } else {
                                        //It's a different collection???!
                                        //Move all of the new collection over to the previous...
                                        //to make one giant collection
                                        for(var t = 0; t < collections[c].length; t++){
                                            if(!collections[col].includes(collections[c][t])){
                                                collections[col].unshift(collections[c][t]);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if(col == -1){ //Matches were found in 1 or more tiles, but no collections were identified
                            matches.unshift(tiles[i][j+1]);
                        }
                    }
                }
                if(matches.length > 1){
                    collections.push(matches);
                    matches = [];
                }
            }
        }

        for(var m = 0; m < collections.length; m++){
            //collections[m]=removeDups(collections[m]);
            collections[m] = [...new Set(collections[m])];
        }
    }
    var selection = undefined;
    function makeSelection(x,y){
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                var t = tiles[i][j];
                if(x < t.x+tileSize.x && x > t.x && y < t.y+tileSize.y && y > t.y){
                    selection = tiles[i][j];
                    break;
                }
            }
            if(selection != undefined){
                break;
            }
        }
        effectedCol = [selection.c];
        getEffectedCol();
        effectedRow = [selection.r];
        getEffectedRow();
    }

    function getEffectedCol(){
        var change = false;
        for(var i = 0; i < effectedCol.length; i++){ //Loop through the effected columns
            for(var j = 0; j < tiles[effectedCol[i]].length;j++){ //Check the rows of those columns
                var t = tiles[effectedCol[i]][j]; //Short hand :)
                for(var f = 0; f < collections.length; f++){ //Loop and see if this tile is in a collection
                    if(collections[f].includes(t)){ //Uh oh we hit a collection
                        for(var d = 0; d < collections[f].length;d++){ //Loop though collection tiles
                            if(!effectedCol.includes(collections[f][d].c)){ //is there a column not already included in the effected list?
                                effectedCol.push(collections[f][d].c);
                                change = true; //Setup for repeat
                            }
                        }
                    }
                }

            }
        }
        effectedCol = [...new Set(effectedCol)]; //Remove duplicates... just in case
        if(change){
            getEffectedCol(); //Let's do it again.
        }
    }

    function getEffectedRow(){
        var change = false;
        for(var j = 0; j < effectedRow.length; j++){
            for(var i = 0; i < tiles.length; i++){
                var t = tiles[i][effectedRow[j]];
                for(var f = 0; f < collections.length; f++){
                    if(collections[f].includes(t)){
                        for(var d = 0; d < collections[f].length; d++){
                            if(!effectedRow.includes(collections[f][d].r)){
                                effectedRow.push(collections[f][d].r);
                                change = true;
                            }
                        }
                    }
                }
            }
        }
        effectedRow = [...new Set(effectedRow)];
        if(change){
            getEffectedRow();
        }
    }

    function collectCols(){
        allCol = [];
        for(var i = 0; i < effectedCol.length;i++){
            for(var j = 0; j < tiles[effectedCol[i]].length; j++){
                allCol.push(tiles[effectedCol[i]][j]);
            }
        }
    }

    function collectRows(){
        allRow = [];
        for(var j = 0; j < effectedRow.length; j++){
            for(var i = 0; i < tiles.length; i++){
                allRow.push(tiles[i][effectedRow[j]]);
            }
        }
    }

    function getClosestPoint(x,y){
        var minDist = (innerWidth*innerHeight)*2;
        var close = undefined;
        for(var i = 0; i < points.length; i++){
            for(var j = 0; j < points[i].length; j++){
                var a = Math.pow(Math.abs(x-points[i][j].x),2);
                var b = Math.pow(Math.abs(y-points[i][j].y),2);
                var c = Math.sqrt(a+b);
                if(c < minDist){
                    minDist = c;
                    close = points[i][j];
                }
            }
        }
        return close;
    }

    // function calculateShift(affected){
    //     //Loop through the affected and get their nearset points
    //     for(var i = 0; i < affected.length; i++){
    //         var close = getClosestPoint(affected[i].x+affected[i].dx,affected[i].y+affected[i].dy);
    //         if(close != undefined){
    //             affected[i].x = close.x;
    //             affected[i].y = close.y;
    //             affected[i].dx = 0;
    //             affected[i].dy = 0;
    //             tiles[close.c][close.r]=affected[i];
    //         }
    //     }
    // }

    function calculateShift(){
        var affected = [];
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                affected.push(tiles[i][j]);
            }
        }
        console.log(affected.length);
        for(var i = 0; i < affected.length; i++){
            var close = getClosestPoint(affected[i].x+affected[i].dx,affected[i].y+affected[i].dy);
            if(close != undefined){
                affected[i].x = close.x;
                affected[i].y = close.y;
                affected[i].dx = 0;
                affected[i].dy = 0;
                if(affected[i].c != close.c){
                    console.log("C: " + affected[i].c + " to " + close.c);
                }
                if(affected[i].r != close.r){
                    console.log("R: " + affected[i].r + " to " + close.r);
                }
                affected[i].c = close.c;
                affected[i].r = close.r;
                tiles[close.c][close.r]=affected[i];

            } else {
                console.log("NO NEARBY POINT FOUND");
            }
        }
    }

    // function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
    //   if (typeof stroke === 'undefined') {
    //     stroke = true;
    //   }
    //   if (typeof radius === 'undefined') {
    //     radius = 5;
    //   }
    //   if (typeof radius === 'number') {
    //     radius = {tl: radius, tr: radius, br: radius, bl: radius};
    //   } else {
    //     var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
    //     for (var side in defaultRadius) {
    //       radius[side] = radius[side] || defaultRadius[side];
    //     }
    //   }
    //   ctx.beginPath();
    //   ctx.moveTo(x + radius.tl, y);
    //   ctx.lineTo(x + width - radius.tr, y);
    //   ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    //   ctx.lineTo(x + width, y + height - radius.br);
    //   ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
    //   ctx.lineTo(x + radius.bl, y + height);
    //   ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
    //   ctx.lineTo(x, y + radius.tl);
    //   ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    //   ctx.closePath();
    //   if (fill) {
    //     ctx.fill();
    //   }
    //   if (stroke) {
    //     ctx.stroke();
    //   }

    // }


//******************************************************************************************
//******************************************************************************************
//******************************************************************************************


    var effectedCol = [];
    var effectedRow = [];
    var allCol = [];
    var allRow = [];
    var dir = -1;
	function animate(){
		window.requestAnimationFrame(animate);
		ctx.clearRect(0,0,innerWidth,innerHeight);

        if(dir > -1){ //Move tiles
            if(dir == 0 || dir == 2){
                //Vertical
                for(var i = 0; i < allCol.length; i++){
                    allCol[i].dy = (current.y-start.y);
                }
            } else if(dir == 1 || dir == 3){
                //Horizontal
                for(var i = 0; i < allRow.length; i++){
                    allRow[i].dx = (current.x-start.x);
                }
            }

        }

        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                tiles[i][j].update();
            }
        }

        if(selection == undefined){
            makeCollections();
        }

        if(DEBUG){
            ctx.fillStyle='#FFF';
            for(var i = 0; i < collections.length; i++){
                var out = i+":";
                for(var j = 0; j < collections[i].length; j++){
                    var t = collections[i][j];
                    out += t.c+","+t.r + " - ";
                }
                ctx.fillText(out,50,i*20+15);
            }
        }
	}


//******************************************************************************************
//******************************************************************************************
//******************************************************************************************

	//*** INPUT SECTION **//
    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        console.log('resize');
        scaleCanvas();
    });

    window.addEventListener('keyup',function(evt){
        evt.preventDefault();
        if(evt.key == 'd'){
            DEBUG = !DEBUG;
        }
    });


    window.addEventListener('mousedown',inputStart,false);
    window.addEventListener('mousemove',inputMove,false);
    window.addEventListener('mouseup',inputEnd,false);

    window.addEventListener('touchstart',inputStart, false);
    window.addEventListener('touchmove', inputMove,false);
    window.addEventListener('touchcancel',inputEnd,false);
    window.addEventListener('touchend',inputEnd,false);

    var start = {x:-1,y:-1};
    var current = {x:-1,y:-1};
    function inputStart(evt){
        evt.preventDefault();
        if(evt.changedTouches != undefined){
            var touches = evt.changedTouches;
            if(touches.length > 0){
                start.x = touches[0].pageX;
                start.y = touches[0].pageY;
            }
        } else {
            start.x = evt.pageX;
            start.y = evt.pageY;
        }
        current.x = start.x; current.y = start.y;
        makeSelection(start.x, start.y);
    }

    function inputMove(evt){
        evt.preventDefault();
        if(start.x > -1){
            if(evt.changedTouches != undefined){
                var touches = evt.changedTouches;
                if(touches.length > 0){
                    current.x = touches[0].pageX;
                    current.y = touches[0].pageY;
                }
            } else {
                current.x = evt.pageX;
                current.y = evt.pageY;
            }

            //Now let's do some drag detection
            if(selection == undefined){
                return;
            }

            var xDif = Math.abs(current.x-start.x);
            var yDif = Math.abs(current.y-start.y);
            if((xDif > dragSensitivity || yDif > dragSensitivity) && dir == -1){
                //We have moved far enough to execute drag
                if(xDif > yDif){
                    if(current.x < start.x){ //left
                        dir = 3;
                    } else { //right
                        dir = 1;
                    }
                    collectRows();
                } else if(yDif > xDif){
                    if(current.y < start.y){ //up
                        dir = 0;
                    } else { //Down
                        dir = 2;
                    }
                    collectCols();
                }
            }
        }
    }

    function inputEnd(){
        // if(allCol.length > 0){
        //     calculateShift(allCol);
        // }
        // if(allRow.length > 0){
        //     calculateShift(allRow);
        // }
        calculateShift();
        start.x = -1; start.y = -1;
        current.x = -1; current.y = -1;
        selection = undefined;
        effectedCol = [];
        effectedRow = [];
        dir = -1;
        allCol = [];
        allRow = [];
    }

    scaleCanvas();
	animate();
	</script>
</body>
</html>
