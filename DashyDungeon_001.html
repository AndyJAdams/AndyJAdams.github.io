<!DOCTYPE HTML>
<html>
<head>
	<meta lang="en/us"/>
	<meta encoding="UTF-8">
	<title>DD</title>
	<style>
		body{
			margin: 0;
			background-color: #FFF;
			touch-action: none;
			position: fixed;
		}
		canvas{
			background-color: #DDD;
		}
	</style>
</head>
<body>
<canvas id='canvas'></canvas>
<script type='text/javascript'>
	var canvas = document.getElementById('canvas');
	var ctx = canvas.getContext('2d');
	var tileCount = 9;
	var tileScale = 0;
	var halfGrid = {
		x: 0,
		y: 0
	};

	function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
		if(innerWidth<innerHeight){
			tileScale = Math.floor((innerWidth*0.6)/tileCount);
		} else {
			tileScale = Math.floor((innerHeight*0.6)/tileCount);
		}
		halfGrid.x = innerWidth/2-((tileScale*tileCount)/2);
		halfGrid.y = innerHeight/2-((tileScale*tileCount)/2);
	}
	scaleCanvas();

	function Tile(x,y,scale,r,c){
		this.x = x;
		this.y = y;
		this.r = r;
		this.c = c;
		this.scale = scale;
		this.status = 'open';
		if(Math.random() < 0.2){
			this.status = 'blocked';
		}

		this.draw = function(){
			//ctx.fillRect(this.x,this.y,this.scale,this.scale);	
			ctx.strokeRect(this.x, this.y, this.scale, this.scale);
			if(this.status == 'blocked'){
				ctx.fillRect(this.x+20,this.y+20,this.scale-40,this.scale-40);
			}
			ctx.fillText(this.r + "," + this.c, this.x+2, this.y+10);
		}

		this.update = function(){
			this.draw();
		}
	}

	function Player(x,y){
		this.x = x; this.y = y; this.dx = this.x; this.dy = this.y;this.dir = 0; this.lastDir = 0;
		this.r = Math.floor(tileCount/2); this.c = Math.floor(tileCount/2);
		this.lastTile = undefined;
		this.draw = function(){
			ctx.strokeRect(this.x+(tileScale/8),this.y+(tileScale/8),tileScale-(tileScale/4),tileScale-(tileScale/4));
			ctx.fillText(this.r + "," + this.c, this.x+12, this.y+20);
			ctx.fillText(this.dir + " / " + this.lastTile,5,20);
		}

		this.moveplayer = function(dir){
			if(this.dir == 0){
				if(dir == 37 || dir == 38 || dir == 39 || dir == 40){
					this.dir = dir;
				}
			}
		}
		this.pushed = undefined;
		this.update = function(){
			if(this.dir != 0){
				if(Math.abs(this.x-this.dx) < 1 && Math.abs(this.y-this.dy) < 1){
					switch(this.dir){
						case 37:
							//Loop throw this row and find endpoint
							for(var i = this.r-1; i > -1; i--){
								if(tiles[i][this.c].status != 'blocked'){
									this.pushed = checkForPushable(i, this.c);
									if(this.pushed != undefined){
										if(!this.pushed.breakable){
											//The object we are about to push cannot break, so we must insure it will move
											if(availableToMove(this.pushed,this.dir)){
												this.lastTile = tiles[i][this.c];
											}
										} else {
											this.lastTile = tiles[i][this.c];
										}
										break;
									} else {
										this.lastTile = tiles[i][this.c];
									}
								} else {
									break;
								}
							}
							if(this.lastTile != undefined){
								this.dx = this.lastTile.x; this.dy = this.y;
								this.r = this.lastTile.r;
							} else {
								this.lastDir = this.dir;
								this.dir = 0;

							}
							break;
						case 38:
							for(var i = this.c-1; i > -1; i--){
								if(tiles[this.r][i].status != 'blocked'){
									this.pushed = checkForPushable(this.r, i);
									if(this.pushed != undefined){
										if(!this.pushed.breakable){
											//The object we are about to push cannot break, so we must insure it will move
											if(availableToMove(this.pushed,this.dir)){
												this.lastTile = tiles[this.r][i];
											}
										} else {
											this.lastTile = tiles[this.r][i];
										}
										break;
									} else {
										this.lastTile = tiles[this.r][i];
									}
								} else {
									break;
								}
							}
							if(this.lastTile != undefined){
								this.dy = this.lastTile.y; this.dx = this.x;
								this.c = this.lastTile.c;
							} else {
								this.lastDir = this.dir;
								this.dir = 0;
							}
							break;
						case 39:
							for(var i = this.r+1; i < tileCount; i++){
								if(tiles[i][this.c].status != 'blocked'){
									this.pushed = checkForPushable(i, this.c);
									if(this.pushed != undefined){
										if(!this.pushed.breakable){
											//The object we are about to push cannot break, so we must insure it will move
											if(availableToMove(this.pushed,this.dir)){
												this.lastTile = tiles[i][this.c];
											}
										} else {
											this.lastTile = tiles[i][this.c];
										}
										break;
									} else {
										this.lastTile = tiles[i][this.c];
									}
								} else {
									break;
								}
							}
							if(this.lastTile != undefined){
								this.dx = this.lastTile.x; this.dy = this.y;
								this.r = this.lastTile.r;
							} else {
								this.lastDir = this.dir;
								this.dir = 0;
							}
							break;
						case 40:
							for(var i = this.c+1; i < tileCount; i++){
								if(tiles[this.r][i].status != 'blocked'){
									this.pushed = checkForPushable(this.r, i);
									if(this.pushed != undefined){
										if(!this.pushed.breakable){
											//The object we are about to push cannot break, so we must insure it will move
											if(availableToMove(this.pushed,this.dir)){
												this.lastTile = tiles[this.r][i];
											}
										} else {
											this.lastTile = tiles[this.r][i];
										}
										break;
									} else {
										this.lastTile = tiles[this.r][i];
									}
								} else {
									break;
								}
							}
							if(this.lastTile != undefined){
								this.dy = this.lastTile.y; this.dx = this.x;
								this.c = this.lastTile.c;
							} else {
								this.lastDir = this.dir;
								this.dir = 0;
							}
							break;
						default:
							this.lastDir = this.dir;
							this.dir = 0;
							this.lastTile = undefined;
							break;
					}
					this.lastDir = this.dir;
					this.dir = 0;
				} 
			} else {
				if(this.pushed != undefined && Math.abs(this.x-this.dx)<2 && Math.abs(this.y-this.dy)<2){
					this.pushed.move(this.lastDir);
					this.pushed = undefined;
				}
			}
			if(this.x < this.dx){
				this.x+= Math.abs(this.x-this.dx)/4;
			} else if(this.x > this.dx){
				this.x-= Math.abs(this.x-this.dx)/4;
			} else if(this.y < this.dy){
				this.y+= Math.abs(this.y-this.dy)/4;
			} else if(this.y > this.dy){
				this.y-= Math.abs(this.y-this.dy)/4;
			} 
			this.draw();
		}
	}

	function availableToMove(p, d){
		var cr = p.r; var cc = p.c;
		switch(d){
			case 37:
				if(cr-1 > -1){
					if(tiles[cr-1][cc].status != 'blocked' && checkForPushable(cr-1,cc) == undefined){
						return true;
					}
				} 
				break;
			case 38:
				if(cc-1 > -1){
					if(tiles[cr][cc-1].status != 'blocked' && checkForPushable(cr,cc-1) == undefined){
						return true;
					}
				} 
				break;
			case 39:
				if(cr+1 < tileCount){
					if(tiles[cr+1][cc].status != 'blocked' && checkForPushable(cr+1,cc) == undefined){
						return true;
					}
				} 
				break;
			case 40:
				if(cc+1<tileCount){
					if(tiles[cr][cc+1].status != 'blocked' && checkForPushable(cr,cc+1) == undefined){
						return true;
					}
				} 
				break;
			default:
				break;
		}
		return false;
	}

	function Pushable(x,y,r,c){
		this.x = x; this.y = y; this.r = r; this.c = c; this.dx = this.x; this.dy = this.y;
		this.lastTile = undefined; this.dir = 0; this.breakable = false; this.broken = false;
		if(Math.random() < 0.35){
			this.breakable = true;
		}
		this.draw = function(){
			if(!this.broken){
				ctx.beginPath();
				ctx.arc(this.x+(tileScale/2),this.y+(tileScale/2),tileScale/4,0,2*Math.PI);
				ctx.stroke();
				ctx.closePath();
				if(this.breakable){
					ctx.beginPath();
					ctx.moveTo(this.x+(tileScale/4),this.y+(tileScale/4));
					ctx.lineTo(this.x+tileScale-(tileScale/4),this.y+tileScale-(tileScale/4));
					ctx.moveTo(this.x+tileScale-(tileScale/4),this.y+(tileScale/4));
					ctx.lineTo(this.x+(tileScale/4),this.y+tileScale-(tileScale/4));
					ctx.stroke();
					ctx.closePath();
				}
			}
		}

		this.move = function(dir){
			if(this.dir == 0){
				if(dir == 37 || dir == 38 || dir == 39 || dir == 40){
					this.dir = dir;
				}
			}
		}

		this.update = function(){
			if(this.dir != 0){
				if(Math.abs(this.x-this.dx) < 1 && Math.abs(this.y-this.dy) < 1){
					switch(this.dir){
						case 37:
							//Loop throw this row and find endpoint
							for(var i = this.r-1; i > -1; i--){
								if(tiles[i][this.c].status != 'blocked'){
									this.lastTile = tiles[i][this.c];
									this.pushed = checkForPushable(i, this.c);
									if(this.pushed != undefined){
										break;
									}
								} else {
									break;
								}
							}
							if(this.lastTile != undefined){
								if(this.lastTile.r == this.r && this.lastTile.c == this.c){
									//We didn't move... are we breakable?
									if(this.breakable){
										this.broken = true;
									} 
								} else {
									this.dx = this.lastTile.x; this.dy = this.y;
									this.r = this.lastTile.r;
								}
							} else {
								this.lastDir = this.dir;
								this.dir = 0;

							}
							break;
						case 38:
							for(var i = this.c-1; i > -1; i--){
								if(tiles[this.r][i].status != 'blocked'){
									this.lastTile = tiles[this.r][i];
									this.pushed = checkForPushable(this.r, i);
									if(this.pushed != undefined){
										break;
									}
								} else {
									break;
								}
							}
							if(this.lastTile != undefined){
								if(this.lastTile.r == this.r && this.lastTile.c == this.c){
									//We didn't move... are we breakable?
									if(this.breakable){
										this.broken = true;
									} 
								} else {
									this.dy = this.lastTile.y; this.dx = this.x;
									this.c = this.lastTile.c;
								}
							} else {
								this.lastDir = this.dir;
								this.dir = 0;
							}
							break;
						case 39:
							for(var i = this.r+1; i < tileCount; i++){
								if(tiles[i][this.c].status != 'blocked'){
									this.lastTile = tiles[i][this.c];
									this.pushed = checkForPushable(i, this.c);
									if(this.pushed != undefined){
										break;
									}
								} else {
									break;
								}
							}
							if(this.lastTile != undefined){
								if(this.lastTile.r == this.r && this.lastTile.c == this.c){
									//We didn't move... are we breakable?
									if(this.breakable){
										this.broken = true;
									} 
								} else {
									this.dx = this.lastTile.x; this.dy = this.y;
									this.r = this.lastTile.r;
								}
							} else {
								this.lastDir = this.dir;
								this.dir = 0;
							}
							break;
						case 40:
							for(var i = this.c+1; i < tileCount; i++){
								if(tiles[this.r][i].status != 'blocked'){
									this.lastTile = tiles[this.r][i];
									this.pushed = checkForPushable(this.r, i);
									if(this.pushed != undefined){
										break;
									}
								} else {
									break;
								}
							}
							if(this.lastTile != undefined){
								if(this.lastTile.r == this.r && this.lastTile.c == this.c){
									//We didn't move... are we breakable?
									if(this.breakable){
										this.broken = true;
									} 
								} else {
									this.dy = this.lastTile.y; this.dx = this.x;
									this.c = this.lastTile.c;
								}
							} else {
								this.lastDir = this.dir;
								this.dir = 0;
							}
							break;
						default:
							this.lastDir = this.dir;
							this.dir = 0;
							this.lastTile = undefined;
							break;
					}
					this.lastDir = this.dir;
					this.dir = 0;
				} 
			} else {
				if(this.pushed != undefined && Math.abs(this.x-this.dx)<2 && Math.abs(this.y-this.dy)<2){
					this.pushed.move(this.lastDir);
					this.pushed = undefined;
				}
			}
			if(this.x < this.dx){
				this.x+= Math.abs(this.x-this.dx)/4;
			} else if(this.x > this.dx){
				this.x-= Math.abs(this.x-this.dx)/4;
			} else if(this.y < this.dy){
				this.y+= Math.abs(this.y-this.dy)/4;
			} else if(this.y > this.dy){
				this.y-= Math.abs(this.y-this.dy)/4;
			} 
			this.draw();
		}
	}



	var tiles = [];
	for(var i = 0; i < tileCount; i++){
		var col = [];
		for(var j = 0; j < tileCount; j++){
			col.push(new Tile(i*tileScale+halfGrid.x,j*tileScale+halfGrid.y,tileScale,i,j));
		}
		tiles.push(col);
	}
	
	var players = [];
	var middleTile = tiles[Math.floor(tileCount/2)][Math.floor(tileCount/2)];
	players.push(new Player(middleTile.x, middleTile.y));

	var pushables = [];
	for(var i = 0; i < Math.floor(Math.random()*7)+1; i++){
		var open = getOpenTiles();
		var randTile = open[Math.floor(Math.random()*open.length)];
		pushables.push(new Pushable(randTile.x, randTile.y, randTile.r, randTile.c));
	}

	function checkForPushable(r,c){
		for(var i =0; i < pushables.length; i++){
			if(pushables[i].r == r && pushables[i].c == c){
				return pushables[i];
			}
		}
		return undefined;
	}

	function getOpenTiles(){
		var openTiles = [];
		for(var i = 0; i < tiles.length; i++){
			for(var j = 0; j < tiles[i].length;j++){
				if(tiles[i][j].status =='open'){
					openTiles.push(tiles[i][j]);
				}
			}
		}
		return openTiles;
	}


	function animate(){
		window.requestAnimationFrame(animate);
		ctx.clearRect(0,0,innerWidth,innerHeight);

		for(var a = 0; a < tiles.length; a++){
			for(var b = 0; b < tiles[a].length; b++){
				tiles[a][b].update();
			}
		}

		for(var c = 0; c < players.length; c++){
			players[c].update();
		}

		for(var d = 0; d < pushables.length; d++){
			pushables[d].update();
		}
		//ctx.fillRect(10,10,tileScale, tileScale);
	}

	function move(dir){
		for(var p = 0; p < players.length; p++){
			players[p].moveplayer(dir);
		}
	}


	window.addEventListener("keyup",function(evt){
		move(evt.keyCode);
	});

	animate();
</script>
</body></html>