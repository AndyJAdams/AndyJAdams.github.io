<!DOCTYPE HTML>
<html>
<head>
	<meta lang="en/us"/>
	<meta encoding="UTF-8">
	<title>Diamond Box</title>
	<style>
		body{
			margin: 0;
			background-color: #222;
			touch-action: none;
			position: fixed;
		}
		canvas{
			background-color: #222;
		}
	</style>
</head>
<body>
<canvas id='canvas'></canvas>
<script type='text/javascript' src='./raw.js'></script>
<script type='text/javascript'>
	var canvas = document.getElementById('canvas');
	var ctx = canvas.getContext('2d');
	
	//GLOBAL VARIABLES
	var GAMEOVER = false;
	var DEBUG = false;
	var spacingX = 0,spacingY = 0;
	var portrait = false;
	var columns =0;
	var rows = 0;
	var color1 = '#000000';
	var color2 = '#DDD';
	var startSpeed = 1;

	function scaleCanvas(r1 = 15,c1=25){
		rows = r1;
		columns = c1;
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight-4;
		if(innerWidth < innerHeight){
			portrait = true;
			var r = rows;
			rows = columns;
			columns = r;
		}
		spacingY = (innerHeight)/(rows+1);
		spacingX = innerWidth/(columns);
		ctx.fillStyle=color1;
		ctx.strokeStyle=color1;
		buildGrid();
	}

	

	function Bit(pos){
		this.pos = pos;
		this.x = pos.x; this.y = pos.y;
		this.moveSpeed = startSpeed;
		this.dx = this.x; this.dy = this.y;
		this.targetPos = undefined;
		this.moving = false;
		this.dir = undefined;
		this.linkArray = [];
		this.draw = function(){
			ctx.fillStyle=color2;
			ctx.beginPath();
			ctx.moveTo(this.x-15,this.y);
			ctx.lineTo(this.x,this.y-15);
			ctx.lineTo(this.x+15,this.y);
			ctx.lineTo(this.x,this.y+15);
			ctx.closePath();
			ctx.fill();
		}

		this.move = function(dir){
			if(this.dir == undefined){
				this.dir = dir;
			}
			this.linkArray = [];
			this.targetPos = this.findEndLink(this.pos, this.dir);
			
			if(this.targetPos != undefined){
				this.dx = this.targetPos.x;
				this.dy = this.targetPos.y;
				this.pos = this.targetPos;
				this.targetPos = undefined;
				this.moving = true;
			} else {
				this.moving = false;
			}
			
		}

		this.update = function(){
			if(this.moving){
				//Determine if we need to wrap move...
				//Now that we set the end point of the move the direction will determine the wrap
				var invert = 1;
				if(this.checkWrap(this.dir,this.x,this.y,this.dx,this.dy)){
					invert=-1;
				}

				if(Math.abs(this.x-this.dx) > 1){
					if(this.x < this.dx){
						this.x += this.moveSpeed*(Math.abs(this.x-this.dx)/10)*invert;
					} else {
						this.x -= this.moveSpeed*(Math.abs(this.x-this.dx)/10)*invert;
					}
				} else if(Math.abs(this.y-this.dy) > 1){
					if(this.y < this.dy){ //SOUTH
						this.y += this.moveSpeed*(Math.abs(this.y-this.dy)/10)*invert;
					} else { //NORTH
						this.y -= this.moveSpeed*(Math.abs(this.y-this.dy)/10)*invert;
					}
				} else {
					for(var i =0; i < this.linkArray.length; i++){
						if(this.dir == 'N' || this.dir == 'S'){
							if(this.linkArray[i].linkV != undefined){
								if(this.linkArray[i].linkV.type == 3){
									this.linkArray[i].linkV = undefined;
								}
							}
						} else if(this.dir == 'W' || this.dir == 'E'){
							if(this.linkArray[i].linkH != undefined){
								if(this.linkArray[i].linkH.type == 3){
									this.linkArray[i].linkH = undefined;
								}
							}
						}
					}
					this.move(this.dir);
				}


				//Horizontal Wrap Reset
				if(this.x < -20){
					this.x = innerWidth+10;
				} else if(this.x > innerWidth+20){
					this.x = -10;
				}

				//Vertical Wrap Reset
				if(this.y < -20){
					this.y = innerHeight+10;
				} else if(this.y > innerHeight+20){
					this.y = -10;
				}
			} else {
				
				this.dir = undefined;
				if(this.pos.omega){
					removeBit(this);
					return;
				}
			}
			this.draw();
		}

		this.checkWrap = function(dir,x1,y1,x2,y2){
			if(dir == 'N'){
				if(y2 > y1){
					return true;
				}
			}
			if(dir == 'S'){
				if(y2 < y1){
					return true;
				}
			}
			if(dir == 'W'){
				if(x2 > x1){
					return true;
				}
			}
			if(dir == 'E'){
				if(x2 < x1){
					return true;
				}
			}
			return false;
		}

		this.findLinkedPos = function(pos,dir){
			if(dir == 'N'){
				for(var i = 0; i < gridPos.length; i++){
					if(gridPos[i].linkV != undefined && gridPos[i].linkV.pos == pos && gridPos[i].linkV.type != 9){
						if(!this.contains(gridPos[i])){
							this.linkArray.push(gridPos[i]);
						} else {
							return undefined;
						}
						return gridPos[i];
					}
				}
			} else if(dir == 'W'){
				for(var i = 0; i < gridPos.length;i++){
					if(gridPos[i].linkH != undefined && gridPos[i].linkH.pos == pos && gridPos[i].linkH.type != 9){
						if(!this.contains(gridPos[i])){
							this.linkArray.push(gridPos[i]);
						} else {
							return undefined;
						}
						return gridPos[i];
					}
				}
			} else if(dir == 'E'){
				if(pos.linkH != undefined && pos.linkH.type != 9){
					if(!this.contains(pos)){
						this.linkArray.push(pos);
					} else {
						return undefined;
					}
					return pos.linkH.pos;
				}
			} else {
				if(pos.linkV != undefined && pos.linkV.type != 9){
					if(!this.contains(pos)){
						this.linkArray.push(pos);
					} else {
						return undefined;
					}
					return pos.linkV.pos;
				}
			}
			return undefined;
		}

		this.findEndLink = function(pos, dir){
			var lk = this.findLinkedPos(pos,dir);
			if(lk != undefined){

				var next = this.findEndLink(lk,dir);
				if(next != undefined){
					return next;
				} else {
					return lk;
				}
			}
			return undefined;
		}

		this.contains = function(pos){
			for(var i =0; i < this.linkArray.length; i++){
				if(this.linkArray[i] == pos){
					return true;
				}
			}
			return false;
		}
	}

	function GridPosition(x,y){
		this.x = x; this.y = y;
		this.linkV = undefined;
		this.linkH = undefined;
		this.alpha = false;
		this.omega = false;
	}

	function Link(pos,type){
		this.pos = pos;
		this.type = type;
	}

	function getGridIndex(pos){
		for(var i =0; i < gridPos.length; i++){
			if(gridPos[i] == pos){
				return i;
			}
		}
		return -1;
	}

	var gridPos = [];
	function buildGrid(){
		gridPos = [];
		for(var y = 0; y < rows; y++){
			for(var x =0; x < columns; x++){
				var posX = Math.floor((x*spacingX)+(spacingX/2));
				var posY = Math.floor((y*spacingY)+(spacingY/2));
				gridPos.push(new GridPosition(posX, posY));
			}
		}
	}

	var bitArray = [];
	function makeBits(){
		bitArray = [];
		for(var i = 0; i < gridPos.length; i++){
			if(gridPos[i].alpha){
				bitArray.push(new Bit(gridPos[i]));
			}
		}
	}

	function removeBit(bit){
		for(var i = 0; i < bitArray.length; i++){
			if(bitArray[i] == bit){
				bitArray.splice(i,1);
			}
		}
	}

	function animate(){
		if(!GAMEOVER){
			window.requestAnimationFrame(animate);
			ctx.clearRect(0,0,innerWidth,innerHeight);

			for(var i =0; i < gridPos.length; i++){
				if(gridPos[i].linkV != undefined){
					drawLinkConnection(gridPos[i],gridPos[i].linkV);
				}
				if(gridPos[i].linkH != undefined){
					drawLinkConnection(gridPos[i],gridPos[i].linkH);
				}

				if(gridPos[i].omega){
					ctx.lineWidth = 2;
					ctx.beginPath();
					ctx.moveTo(gridPos[i].x-15,gridPos[i].y);
					ctx.lineTo(gridPos[i].x,gridPos[i].y-15);
					ctx.lineTo(gridPos[i].x+15,gridPos[i].y);
					ctx.lineTo(gridPos[i].x,gridPos[i].y+15);
					ctx.closePath();
					ctx.fillStyle=color1;
					ctx.strokeStyle=color2;
					ctx.fill();
					ctx.stroke();
				}
			}

			if(bitArray.length > 0){
				for(var b = 0; b < bitArray.length;b++){
					bitArray[b].update();
				}
			} else {
				if(urlData != null){
					loadURLData();
				} else {
					level++;
					clearMap();
					loadLevelData();
				}
			}

			if(DEBUG){
				ctx.textAlign = 'start';
				// ctx.fillText(rows+"x"+columns,5,innerHeight-10);
				// ctx.fillText("@"+mx+","+my,5,innerHeight-30);
			}
		}
	}

	function drawLinkConnection(pos,link){
		var m = link.type;
		ctx.lineWidth = 2;
		ctx.strokeStyle = color2;
		switch(m){
			case 2: //Solid
				ctx.setLineDash([]);
				ctx.beginPath();
				ctx.moveTo(pos.x,pos.y);
				ctx.lineTo(link.pos.x,link.pos.y);
				ctx.stroke();
				ctx.closePath();
				break;
			case 3: //Dashed
				ctx.setLineDash([3,6]);
				ctx.beginPath();
				ctx.moveTo(pos.x,pos.y);
				ctx.lineTo(link.pos.x,link.pos.y);
				ctx.stroke();
				ctx.closePath();
				ctx.setLineDash([]);
				break;
			case 4: //Wrap
				ctx.setLineDash([]);
				if(Math.abs(pos.x-link.pos.x)>spacingX*2){ //Horizontal
					if(pos.x < link.pos.x){ //LEFT
						ctx.beginPath();
						ctx.moveTo(pos.x,pos.y);
						ctx.lineTo(-20,pos.y);
						ctx.moveTo(link.pos.x,link.pos.y);
						ctx.lineTo(innerWidth+20,link.pos.y);
						ctx.stroke();
						ctx.closePath();
					} else { //RIGHT
						ctx.beginPath();
						ctx.moveTo(pos.x,pos.y);
						ctx.lineTo(innerWidth+20,pos.y);
						ctx.moveTo(link.pos.x,link.pos.y);
						ctx.lineTo(-20,link.pos.y);
						ctx.stroke();
						ctx.closePath();
					}
				} else if(Math.abs(pos.y-link.pos.y)>spacingY*2){//Vertical
					if(pos.y < link.pos.y){//UP
						ctx.beginPath();
						ctx.moveTo(pos.x,pos.y);
						ctx.lineTo(pos.x,-20);
						ctx.moveTo(link.pos.x,link.pos.y);
						ctx.lineTo(link.pos.x,innerHeight+20);
						ctx.stroke();
						ctx.closePath();
					} else {//DOWN
						ctx.beginPath();
						ctx.moveTo(pos.x,pos.y);
						ctx.lineTo(pos.x,innerHeight+20);
						ctx.moveTo(link.pos.x,link.pos.y);
						ctx.lineTo(link.pos.x,-20);
						ctx.stroke();
						ctx.closePath();
					}
				}
				break;
			default:
				break;
		}
	}

	function getGridIndex(pos){
		for(var i =0; i < gridPos.length;i++){
			if(pos == gridPos[i]){
				return i;
			}
		}
		return -1;
	}

	function clearMap(){
		for(var i =0; i < gridPos.length;i++){
			gridPos[i].alpha = false;
			gridPos[i].omega = false;
			gridPos[i].linkV = undefined;
			gridPos[i].linkH = undefined;
		}
	}

	function applyMove(dir){
		if(checkMoving()){
			for(var i = 0; i < bitArray.length; i++){
				bitArray[i].move(dir);
			}
		}
	}

	function checkMoving(){
		for(var i = 0; i < bitArray.length; i++){
			if(bitArray[i].moving){
				return false;
			}
		}
		return true;
	}

	//------INPUT CONTROLS ---------------------------------------
	//Input variables
	var mx, my;
	var sx, sy;


	window.addEventListener('resize', function(){
		scaleCanvas(rows,columns);
	});

	//Mouse
	window.addEventListener('mousedown', function(evt){
    	evt.preventDefault();
    	sx = evt.pageX;
    	sy = evt.pageY;
    },false);
    window.addEventListener('mousemove', function(evt){
    	evt.preventDefault();
    	mx = evt.pageX;
    	my = evt.pageY;
    },false);
    window.addEventListener('mouseup', function(evt){
    	evt.preventDefault();
		var d = Math.sqrt(Math.pow(Math.abs(sx-mx),2)+Math.pow(Math.abs(sy-my),2));
		if(d > spacingX/2||d > spacingY/2){
    		var xdiff = Math.abs(sx-mx); var ydiff = Math.abs(sy-my);
    		if(xdiff > ydiff){
    			if(sx < mx){
    				applyMove('E');
    			} else {
    				applyMove('W');
    			}
    		} else {
    			if(sy < my){
    				applyMove('S');
    			} else {
    				applyMove('N');
    			}
    		}
    	}
    },false);

    //Keyboard
	window.addEventListener('keyup',function(evt){
		evt.preventDefault();
		switch(evt.keyCode){
			case 80: //P
				DEBUG = !DEBUG;
				break;
			case 37: //L-Arrow
				applyMove('W');
				break;
			case 38: //Up-Arrow
				applyMove('N');
				break;
			case 39: //R-Arrow
				applyMove('E');
				break;
			case 40: //Dn-Arrow
				applyMove('S');
				break;
			default:
				break;
		}
	});

	//Touch
	window.addEventListener('touchstart', function(evt){
        evt.preventDefault();
		mx = evt.changedTouches[0].pageX;
        my = evt.changedTouches[0].pageY;
        sx = mx;
        sy = my;
    }, false);
	
    window.addEventListener('touchmove', function(evt){
        evt.preventDefault();
        mx = evt.changedTouches[0].pageX;
        my = evt.changedTouches[0].pageY; 
    }, false);
	
    window.addEventListener('touchcancel', function(evt){
        evt.preventDefault();
    }, false);
	
	//User has removed finger... let's figure out the desired action here. 
    window.addEventListener('touchend', function(evt){
        evt.preventDefault();
    	var d = Math.sqrt(Math.pow(Math.abs(sx-mx),2)+Math.pow(Math.abs(sy-my),2));
		if(d > spacingX/2||d > spacingY/2){
    		var xdiff = Math.abs(sx-mx); var ydiff = Math.abs(sy-my);
    		if(xdiff > ydiff){
    			if(sx < mx){
    				applyMove('E');
    			} else {
    				applyMove('W');
    			}
    		} else {
    			if(sy < my){
    				applyMove('S');
    			} else {
    				applyMove('N');
    			}
    		}
    	}
    }, false);

    //Data Management
    function getURLVars(){
		var vars={};
		var parts = window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi,function(m,key,value){
			vars[key] = decodeURI(value);
		});
		return vars;
	}

	var level = 0;

	var urlData = getURLVars()['data'];
	if(urlData != null && urlData != undefined){
		console.log(urlData);
	} else {
		loadLevelData();
	}

	function loadLevelData(){
		if(raw[level] != ''){
			data = raw[level].split(',');
			rows = parseInt(data[0].split('.')[0]);
			columns = parseInt(data[0].split('.')[1]);
			scaleCanvas(rows,columns);
			var starts = data[1].split('.');
			for(var i = 0; i < starts.length; i++){
				if(starts[i] != ''){
					gridPos[parseInt(starts[i])].alpha = true;
				}
			}
			var linked = data[2].split('.');
			for(var l = 0; l < linked.length;l++){
				if(linked[l] != ''){
					var subData = linked[l].split('-');
					var sx = gridPos[parseInt(subData[0])].x; var sy = gridPos[parseInt(subData[0])].y;
					var ex = gridPos[subData[1]].x; var ey = gridPos[subData[1]].y;
					var nLink = new Link(gridPos[parseInt(subData[1])],parseInt(subData[2]));
					if(Math.abs(sx-ex)>spacingX/2){ //Horizontal
						gridPos[parseInt(subData[0])].linkH = nLink;
					} else { //Vertical
						gridPos[parseInt(subData[0])].linkV = nLink;
					}
				}
			}

			var ends = data[3].split('.');
			for(var e = 0; e < ends.length; e++){
				if(ends[e] != ''){
					gridPos[parseInt(ends[e])].omega = true;
				}
			}
			makeBits();
			animate();
			//15.25,162.,162-187-2.187-212-2.212-237-2.,237.
		} else {
			console.log("END GAME : Levels " + level);
			GAMEOVER = true;
			ctx.clearRect(0,0,innerWidth,innerHeight);
		}
	} 

	function loadURLData(data){
		if(data == ''){
			console.log("URL DATA EMPTY");
			loadLevelData();
		} else {
			rows = parseInt(data[0].split('.')[0]);
			columns = parseInt(data[0].split('.')[1]);
			scaleCanvas(rows,columns);
			var starts = data[1].split('.');
			for(var i = 0; i < starts.length; i++){
				if(starts[i] != ''){
					gridPos[parseInt(starts[i])].alpha = true;
				}
			}
			var linked = data[2].split('.');
			for(var l = 0; l < linked.length;l++){
				if(linked[l] != ''){
					var subData = linked[l].split('-');
					var sx = gridPos[parseInt(subData[0])].x; var sy = gridPos[parseInt(subData[0])].y;
					var ex = gridPos[subData[1]].x; var ey = gridPos[subData[1]].y;
					var nLink = new Link(gridPos[parseInt(subData[1])],parseInt(subData[2]));
					if(Math.abs(sx-ex)>spacingX/2){ //Horizontal
						gridPos[parseInt(subData[0])].linkH = nLink;
					} else { //Vertical
						gridPos[parseInt(subData[0])].linkV = nLink;
					}
				}
			}

			var ends = data[3].split('.');
			for(var e = 0; e < ends.length; e++){
				if(ends[e] != ''){
					gridPos[parseInt(ends[e])].omega = true;
				}
			}
			makeBits();
			animate();
		}
	}
	
</script>
</body>
</html>