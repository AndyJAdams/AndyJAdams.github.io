<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Twenty1</title>
	<style type="text/css">
		body, html{ 
			margin: 0; 
			position: fixed;
		}
		canvas{
            touch-action: none;
            background-color: #5ea671;
		}
		img {
			width: 128px;
			height: 128px;
		}
	</style>
</head>
<body id='body'>
	<canvas id='canvas'></canvas>
	<img id='reset' src='https://www.shareicon.net/data/128x128/2015/08/23/89631_refresh_512x512.png'/>
	<script>
	//Locate the canvas element
	var canvas = document.getElementById('canvas');
	
	//Scale to full screen
	function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	}
	scaleCanvas();

	//Get the 2D Drawing context for our 2D game
	var ctx = canvas.getContext('2d');

	//Display debug data on blocks
	var DebugDisplay = false;

	//Grid valey width via block insets
	var inset = 10;

	//Track highest value for this round

	var gridRows = 8; //number of rows
	var gridCols = 7; // number of columns

	var score = 0;
	var failboat = false;
	
	//Object for position data storage
	var topPosition = {
		x: -1,
		y: -1
	};

	//Block Object
	function Block(x,y,w,h,value,r,c,col){
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
		this.r = r;
		this.c = c;
		this.dx = this.x;
		this.dy = this.y;
		this.value = value;
        this.col = col;

		this.draw = function(){
			ctx.fillStyle = '#FFF';
            if(failboat){
                ctx.fillStyle='#000';
            }
			roundRect(ctx,this.x+(inset/2), this.y+(inset/2), this.w-inset, this.h-inset,15,true,false);
			
		}

		this.update = function(){
			//Called every frame... 
			//TODO: Add animation data for movement of blocks. 
			if(this.x != this.dx){
				this.x = lerp(this.x,this.dx,0.1);
			}
			if(this.x != this.dy){
				this.y = lerp(this.y,this.dy,0.1);
			}

			this.draw();
		}

		this.label = function(){
			ctx.font = 'bold 42px Tahoma';
            if(blockScale < 100){
                ctx.font = 'bold 24px Tahoma';
            }
            if(this.w > inset){
			 ctx.fillStyle=this.col;
                if(failboat){
                    ctx.fillStyle='#FFF';
                }
                var fontOffset = blockScale/2;
			 ctx.fillText(this.value +'', this.x+15, this.y+fontOffset);
			 	if(DebugDisplay){
			 		//Row & Column [BOTTOM RIGHT]
            		ctx.font ='28px Arial';
            		ctx.fillStyle = '#888';
            		ctx.fillText(this.r + "," + this.c,this.x+(this.w)-50,this.y+(this.w)-15);
            		//Raw position [TOP LEFT]
            		ctx.font = '26px Arial';
            		ctx.fillStyle = '#BBB';
            		ctx.fillText(Math.round(this.x) + "," + Math.round(this.y),this.x+8,this.y+30);
            	}
            }
            
		}
	}	
    
    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof stroke === 'undefined') {
        stroke = true;
      }
      if (typeof radius === 'undefined') {
        radius = 5;
      }
      if (typeof radius === 'number') {
        radius = {tl: radius, tr: radius, br: radius, bl: radius};
      } else {
        var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
        for (var side in defaultRadius) {
          radius[side] = radius[side] || defaultRadius[side];
        }
      }
      ctx.beginPath();
      ctx.moveTo(x + radius.tl, y);
      ctx.lineTo(x + width - radius.tr, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      ctx.lineTo(x + width, y + height - radius.br);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
      ctx.lineTo(x + radius.bl, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
      ctx.lineTo(x, y + radius.tl);
      ctx.quadraticCurveTo(x, y, x + radius.tl, y);
      ctx.closePath();
      if (fill) {
        ctx.fill();
      }
      if (stroke) {
        ctx.stroke();
      }

    }

	function Restart (x,y){
		this.x = x;
		this.y = y;
		this.draw = function(){
			var reset = document.getElementById('reset');
            if(blockScale < 100){
                ctx.drawImage(reset,this.x+64,this.y+60,64,64);
            } else {
                ctx.drawImage(reset,this.x,this.y,128,128);
            }
			
			//ctx.drawImage(reset,(innerWidth/2)-gridWidth/2+gridWidth-120,(innerHeight/2)-gridHeight/2-150);
		}
	}

	function lerp (start, end, amt){
  		return (1-amt)*start+amt*end
	}

	//Extend Array to support multidimensions via .matrix function
	//We pass rows and then columns
	Array.matrix = function(rows,columns){
		var row = [];
		for(var i = 0; i < rows; i++){
			var col = [];
			for(var j = 0; j < columns; j++){
				col[j] = undefined;
			}
			row[i] = col;
		}
		//An array of columns contains a block from each row within it. 
		return row;
	}

	

	var blockScale = ((innerWidth*0.9)/gridCols); //Since this is mobile centric... we base our scale of overall width or number of columns
        if(innerWidth > innerHeight){
            blockScale = ((innerHeight*0.6)/gridCols);
        }
	var blockArray = Array.matrix(gridRows,gridCols); //Make the array

	var gridHeight = (blockScale * gridRows); //Height of grid used for centering
	var gridWidth = (blockScale * gridCols); //Width of grid used for centering

	var resetBTN = new Restart((innerWidth/2)-gridWidth/2+gridWidth-120,(innerHeight/2)-gridHeight/2-150);

	function initGrid(){
		//Let's make some blocks!

		for(var x = 0; x < gridRows; x++){ //Iterate through cols
			for(var y = 0; y < gridCols; y++){ //iterate through rows
				var xpos = (y*blockScale)+(innerWidth/2-gridWidth/2); //this is the xposition but x is actually the column
				var ypos = (x*blockScale)+(innerHeight/2-gridHeight/2); //this is the yposition but y is the rows since rows stack upward (e.g. Y AXIS)
                var col = '#000';
                if(Math.random()>0.5){
                    col = '#F00';
                }
				blockArray[x][y] = new Block(xpos, ypos,blockScale,blockScale,Math.round(Math.random()*8)+1,x,y,col); //Make the block
				
				if(x == 0 && y == 0){
					topPosition.x = xpos;
					topPosition.y = ypos;
				}

			}
		}
	}

	initGrid();

	//Game loop [ ~ 60FPS ]
	function animate(){

		//Recursive call (Basically the game's do-while playing loop)
		window.requestAnimationFrame(animate);
		//Clear the whole screen every frame
		ctx.clearRect(0,0,innerWidth,innerHeight);
        
        //Update and label the blocks every frame
		for(var i = 0; i < blockArray.length; i++){
			for(var j = 0; j < blockArray[i].length; j++){
	            if(blockArray[i][j] != undefined){
	                blockArray[i][j].update();
		            blockArray[i][j].label();
	            }
	        }
		}

		resetBTN.draw();

		ctx.font = 'bold 128px Tahoma';
        if(blockScale < 100){
            ctx.font = 'bold 64px Tahoma';
        }
		ctx.fillStyle = '#000';
		ctx.fillText(score + '',(innerWidth/2-gridWidth/2),(innerHeight/2-gridHeight/2)-40);
		
	}

	var mx = 0; //Touch || Mouse initial input position on x
    var my = 0; //Touch || Mouse initial input position on y

    //Find the block closest to the page mapped position
	var closestBlock = undefined;    
	function findClosestBlock(a,b){
		for(var i = 0; i < blockArray.length;i++){
			for(var j = 0; j < blockArray[i].length; j++){
				if(
	                blockArray[i][j] != undefined && 
	                a > blockArray[i][j].x && 
	                a < blockArray[i][j].x+blockArray[i][j].w && 
	                b > blockArray[i][j].y && 
	                b < blockArray[i][j].y+blockArray[i][j].h
	            ){
					return blockArray[i][j];
				}
			}
		}
        return undefined;
	}

	window.addEventListener('touchstart', function(evt){
        evt.preventDefault();
		mx = evt.changedTouches[0].pageX;
        my = evt.changedTouches[0].pageY; 
    }, false);
	
    window.addEventListener('touchmove', function(evt){
        evt.preventDefault();
    }, false);
	
    window.addEventListener('touchcancel', function(evt){
        evt.preventDefault();
        closestBlock = undefined;
    }, false);
	
	//User has removed finger... let's figure out the desired action here. 
    window.addEventListener('touchend', function(evt){
        evt.preventDefault();
        //Where did the finger / pointer disengage?
        var emx = evt.changedTouches[0].pageX;
        var emy = evt.changedTouches[0].pageY;

        //What is the closest block to the starting touch?
        closestBlock = findClosestBlock(mx,my);

        if(closestBlock != undefined){
        	var cval = closestBlock.value; 
            if(Math.abs(emx-mx) > Math.abs(emy-my)){
                //Horizontal
                if(Math.abs(emx-mx) > blockScale/2){
                    if(emx-mx > 0){ //The finger actually moved in some direction... this will later be tweaked as drag sensitivity
                        //Right
                        var rblock = findClosestBlock(mx+blockScale,emy); //Closest block in the direction of the end position. 
                        if(rblock != undefined){
                            var rval = rblock.value;
                            if(rval+cval < 22){
                            	if(validMove(rblock,closestBlock)){ //Insure cardinal direction movements only 
	                                rblock.value = rval+cval; //Assign sum to end block
	                                closestBlock.w = inset; //Devalue/Remove the dragged block
	                                Remove21(); //Call to remove blocks of 21 and then drop to fill gaps.
	                            }
                            }
                        }
                    } else if(emx-mx < 0){
                        //Left
                        var lblock = findClosestBlock(mx-blockScale,emy);
                        if(lblock != undefined){
                        	var lval = lblock.value;
                        	if(lval+cval < 22){
                        		if(validMove(lblock,closestBlock)){
	                        		lblock.value = lval + cval;
	                        		closestBlock.w = inset;
	                        		Remove21();
	                        	}
                        	} 
                        }
                    }
                }
            } else {
                if(Math.abs(emy-my) > blockScale/2){
                    if(emy-my > 0){
                        //Down
                        var dblock = findClosestBlock(emx,blockScale+my);
                        if(dblock != undefined){
                        	var dval = dblock.value;
                        	if(dval+cval < 22){
                        		if(validMove(dblock,closestBlock)){
	                        		dblock.value = dval + cval;
	                        		closestBlock.w = inset;;
	                        		Remove21();
	                        	}
                        	}
                        }
                    } else if(emy-my < 0){
                        //Up
                        var ublock = findClosestBlock(emx,my-blockScale);
                        if(ublock != undefined){
                        	var uval = ublock.value;
                        	if(uval+cval < 22){
                        		if(validMove(ublock,closestBlock)){
	                        		ublock.value = uval+cval;
	                        		closestBlock.w = inset;
	                        		Remove21();
	                        	}
                        	}
                        }
                    }
                }
            }
            
        } else {
        	//Check to see if user is clicking restart...
        	if(emx > resetBTN.x && emx < resetBTN.x+128 && emy > resetBTN.y && emy < resetBTN.y+128){
        		RestartGame();
        	}
        }

        closestBlock = undefined; //reset touch parameters
    }, false);

    function RestartGame(){
    	failboat = false;
    	var blockArray = Array.matrix(gridRows,gridCols); //Make the array
    	initGrid();
    	score = 0;
    }

    function validMove(a,b){
    	if(a.r == b.r || a.c == b.c){ //Actions only available in 4 cardinal directions
    		return true;
    	}
    	return false;
    }

    function Remove21(){
    	for(var i = 0; i < blockArray.length; i++){
    		for(var j = 0; j < blockArray[i].length; j++){
	    		if(blockArray[i][j].value == 21){
	    			score++;
	    			blockArray[i][j].w = inset;
	    		} 
	    	}
    	}
    	DropBlocks();
    }

    function RebuildBlock(x,y,endY){
    	var highestVal = -1;
    	for(var i = 0; i < blockArray.length; i++){
    		for(var j = 0; j < blockArray[i].length; j++){
    			if(blockArray[i][j].value > highestVal){
    				highestVal = blockArray[i][j].value;
    			}
    		}
    	}
    	if(highestVal == -1){
    		highestVal = Math.round(Math.random()*8)+1;
    	}

    	if(highestVal > 15){
    		highestVal = 15;
    	}

    	blockArray[x][y].y = topPosition.y-blockScale;
    	blockArray[x][y].value = Math.round(Math.random()*(highestVal-1))+1;
    	blockArray[x][y].w = blockScale;
    	blockArray[x][y].dy = endY;
    }

    function DropBlocks(){
    	for(var i = blockArray.length-1; i > -1; i--){
    		for(var j = blockArray[i].length-1; j > -1; j--){
    			if(blockArray[i][j].w < inset+20){
    				var u = -1;
    				for(var x = i-1; x > -1; x--){
    					if(blockArray[x][j].w > inset && u == -1){
    						u = x; 
    					}
    				}
    				if(u == -1){
    					//NO REPLACEMENT FOUND
    					RebuildBlock(i,j,blockArray[i][j].dy);
    				} else {
    					var uy = blockArray[u][j].dy;
    					var ur = blockArray[u][j].r;
    					blockArray[u][j].dy = blockArray[i][j].dy;
    					blockArray[u][j].r = blockArray[i][j].r;
    					blockArray[i][j].dy = uy;
    					blockArray[i][j].y = uy; //move the empty block instantly
    					blockArray[i][j].r = ur;
    					var org = blockArray[i][j];
    					blockArray[i][j] = blockArray[u][j];
    					blockArray[u][j] = org;
    				}
    			}
    		}
    	}
    	if(ValidateGrid()){
    		failboat = true;
    	}
    }

    function ValidateGrid(){
    	for(var x = 0; x < blockArray.length; x++){
    		for(var y = 0; y < blockArray[x].length; y++){
    			var bval = blockArray[x][y].value;
    			if(x+1 < blockArray.length){
    				if(blockArray[x+1][y].value + bval < 22){
    					return false;
    				}
    			}
    			if(y+1 < blockArray[x].length){
    				if(blockArray[x][y+1].value + bval < 22){
    					return false;
    				}
    			}
    		}
    	}
    	return true;
    }

	animate();
	</script>
</body>
</html>