<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>INFINITE TIC-TAC-TOE</title>
	<style type="text/css">
		body{
            margin: 0;
            touch-action: none;
            position: fixed;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
        }
        canvas{
            touch-action: none;
            background-color: #DDD;
        }
	</style>
</head>
<body id='body'>
<canvas></canvas>
	<script>
	var canvas = document.querySelector('canvas');
	var half = {x: -1, y: -1};
	var boxSize = -1;
	var centers = [];
	var spots = [];
	var xMoves = [];
	var oMoves = [];
	var xTurn = true;
	var winner = -1;
	var moveLimit = 3;
	var winTimer = 0;
	
    function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
		half.x = canvas.width/2;
		half.y = canvas.height/2;
		boxSize = (canvas.height * 0.8) / 3;
		if(canvas.width < canvas.height){
			//portrait
			boxSize = (canvas.width*0.8)/3;
		}
		
		//DETERMINE 9 centers
		centers[0] = {x: half.x-boxSize, y: half.y-boxSize};
		centers[1] = {x: half.x, y: half.y-boxSize};
		centers[2] = {x: half.x+boxSize, y: half.y-boxSize};
		centers[3] = {x: half.x-boxSize, y: half.y};
		centers[4] = {x: half.x, y: half.y};
		centers[5] = {x: half.x+boxSize, y: half.y};
		centers[6] = {x: half.x-boxSize, y: half.y+boxSize};
		centers[7] = {x: half.x, y: half.y+boxSize};
		centers[8] = {x: half.x+boxSize, y: half.y+boxSize};
		
		for(var s = 0; s < 9; s++){
			spots[s] = undefined;
		}
	}
	var ctx = canvas.getContext('2d');
    scaleCanvas();


	function resetGame() {
		xMoves = [];
		oMoves = [];
		winner = -1;
		xTurn = true;
        for (var s = 0; s < 9; s++) {
            spots[s] = undefined;
        }
		//console.log("RESET");
	}
	
    //*************************************************
    //*************************************************
	function animate(){
		window.requestAnimationFrame(animate);
		ctx.clearRect(0,0,innerWidth,innerHeight);
		ctx.fillStyle = "#000";

        //Draw bars for grid
        ctx.fillRect(half.x - (boxSize / 2) - 5, half.y - (boxSize * 1.5) - 5, 10, boxSize * 3 + 10);
        ctx.fillRect(half.x + (boxSize / 2) - 5, half.y - (boxSize * 1.5) - 5, 10, boxSize * 3 + 10);
        ctx.fillRect(half.x - (boxSize * 1.5) - 5, half.y - (boxSize / 2) - 5, boxSize * 3, 10);
        ctx.fillRect(half.x - (boxSize * 1.5) - 5, half.y + (boxSize / 2) - 5, boxSize * 3, 10);
        ctx.strokeStyle = "#000";
        //DRAW X's

		for (var i = 0; i < xMoves.length; i++) {
            var s = xMoves[i];
            if (xMoves.length >= moveLimit && i == xMoves.length - 1) {
                //Draw the first x as an outline
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.moveTo(centers[s].x - (boxSize / 2) + 45, centers[s].y - (boxSize / 2) + 15);
                ctx.lineTo(centers[s].x - (boxSize / 2) + 15, centers[s].y - (boxSize / 2) + 45);
                ctx.lineTo(centers[s].x - 25, centers[s].y);
                ctx.lineTo(centers[s].x - (boxSize / 2) + 15, centers[s].y + (boxSize / 2) - 45);
                ctx.lineTo(centers[s].x - (boxSize / 2) + 45, centers[s].y + (boxSize / 2) - 15);
                ctx.lineTo(centers[s].x, centers[s].y + 25);
                ctx.lineTo(centers[s].x + (boxSize / 2) - 45, centers[s].y + (boxSize / 2) - 15);
                ctx.lineTo(centers[s].x + (boxSize / 2) - 15, centers[s].y + (boxSize / 2) - 45);
                ctx.lineTo(centers[s].x + 25, centers[s].y);
                ctx.lineTo(centers[s].x + (boxSize / 2) - 15, centers[s].y - (boxSize / 2) + 45);
                ctx.lineTo(centers[s].x + (boxSize / 2) - 45, centers[s].y - (boxSize / 2) + 15);
                ctx.lineTo(centers[s].x, centers[s].y - 25);
                ctx.closePath();
                ctx.stroke();
            } else {
                ctx.lineWidth = 40;
                ctx.beginPath();
                ctx.moveTo(centers[s].x - (boxSize / 2) + 30, centers[s].y - (boxSize / 2) + 30);
                ctx.lineTo(centers[s].x + (boxSize / 2) - 30, centers[s].y + (boxSize / 2) - 30);
                ctx.moveTo(centers[s].x + (boxSize / 2) - 30, centers[s].y - (boxSize / 2) + 30);
                ctx.lineTo(centers[s].x - (boxSize / 2) + 30, centers[s].y + (boxSize / 2) - 30);
                ctx.stroke();
            }
            ctx.fillText("" + xMoves[i], 10, i * 12 + 10);
        }
        //DRAW O's
        for (var i = 0; i < oMoves.length; i++) {
            var s = oMoves[i];
            if (oMoves.length >= moveLimit && i == oMoves.length - 1) {
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.arc(centers[s].x, centers[s].y, boxSize / 2 - 25, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(centers[s].x, centers[s].y, boxSize / 2 - 50, 0, 2 * Math.PI);
                ctx.stroke();
            } else {
                ctx.lineWidth = 40;
                ctx.beginPath();
                ctx.arc(centers[s].x, centers[s].y, boxSize / 2 - 40, 0, 2 * Math.PI);
                ctx.stroke();
            }
            ctx.fillText("" + oMoves[i], 40, i * 12 + 10);
		}
        
		
		if (winner > -1) { //Someone has won the game
			ctx.fillStyle = "#00000088";
			if (winner == 0) {
				//O's win
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.strokeStyle = "#DDD";
				ctx.beginPath();
				ctx.arc(centers[4].x, centers[4].y, boxSize, 0, 2 * Math.PI);
				ctx.stroke();
			} else {
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				ctx.strokeStyle = "#DDD";
				ctx.beginPath();
				ctx.moveTo(centers[0].x, centers[0].y);
				ctx.lineTo(centers[8].x, centers[8].y);
				ctx.moveTo(centers[2].x, centers[2].y);
				ctx.lineTo(centers[6].x, centers[6].y);
				ctx.stroke();
			}
		} else {
            validate();
            limitMoves();
		}

		
	}
    //*************************************************
    //*************************************************

	function validate() {
		if (xMoves.length > 2 || oMoves.length > 2) {
			//There are only 8 possible winning combinations so we need to sort the x and o arrays numerically to determine if it matches one of those combos
			//First the sorting as always x first - we dup the array so we don't lose placement order
			xArr = xMoves.slice();
			xArr.sort((a, b) => a - b);
			if (checkArr(xArr)) {
				winner = 1;
				winTimer = Date.now() + 3000;
			} else {
				oArr = oMoves.slice();
				oArr.sort((a, b) => a - b);
				if (checkArr(oArr)) {
					winner = 0;
				} else {
					winner = -1;
					winTimer = Date.now() + 3000;
				}
			}
		}
	}

	function checkArr(arr) {
		var result = false;
		var str = "";
		for (var i = 0; i < arr.length; i++) {
			str += arr[i]+"";
		}
		switch (str) {
			case "012":
			case "036":
			case "048":
			case "147":
			case "246":
			case "258":
			case "345":
			case "678":
				result = true;
				break;
			default:
				result = false;
				break;
		}
		return result;
	}

	//*** INPUT SECTION **//
    window.addEventListener('keyup',function(e){
        console.log(e.keyCode);
    });

    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        scaleCanvas();
    });

    window.addEventListener('mousedown',inputStart,false);
    window.addEventListener('mousemove',inputMove,false);
    window.addEventListener('mouseup',inputEnd,false);

    window.addEventListener('touchstart',inputStart, false);
    window.addEventListener('touchmove', inputMove,false);
    window.addEventListener('touchcancel',inputEnd,false);
    window.addEventListener('touchend',inputEnd,false);

    var start = {x:-1,y:-1};
		var current = {x:-1,y:-1};
    function inputStart(evt){
        evt.preventDefault();
        if(evt.changedTouches != undefined){
            var touches = evt.changedTouches;
            if(touches.length > 0){
                start.x = touches[0].pageX;
                start.y = touches[0].pageY;
            }
        } else {
            start.x = evt.pageX;
            start.y = evt.pageY;
        }
				current.x = start.x;
				current.y = start.y;
    }

    function inputMove(evt){
        evt.preventDefault();
        if(start.x > -1){
            if(evt.changedTouches != undefined){
                var touches = evt.changedTouches;
                if(touches.length > 0){
                    current.x = touches[0].pageX;
                    current.y = touches[0].pageY;
                }
            } else {
                current.x = evt.pageX;
                current.y = evt.pageY;
            }
        }
    }
	
	function closestSpot(x, y){
		var dist = boxSize * 100;
		var index = -1;
		for(var i = 0; i < centers.length; i++){
			var d = Math.sqrt(Math.abs(Math.pow(x-centers[i].x,2)+Math.pow(y-centers[i].y,2)));
			if(d < dist){
				dist = d;
				index = i;
			}
		}
		return index;
	}
	
	function limitMoves(){		
		//UPDATE THE TRACKING GRIDS
		if(oMoves.length > moveLimit){ //IF THERE HAVE BEEN ENOUGH MOVES
			spots[oMoves[oMoves.length-1]] = undefined; //RESET VERY FIRST MOVE
			oMoves.pop(); //REMOVE THE OLD MOVE FROM TRACKING
		}
		if(xMoves.length > moveLimit){
			spots[xMoves[xMoves.length-1]] = undefined;
			xMoves.pop();
		}
	}
	

    function inputEnd(){
		if (winner < 0) {
			//console.log(start);
			//TAP INSIDE THE BOUNDS OF THE GRID PLEASE
			if (start.x < half.x + boxSize * 1.5 && start.y < half.y + boxSize * 1.5 && start.x > half.x - boxSize * 1.5 && start.y > half.y - boxSize * 1.5) {
				//GET THE CLOSEST GRID SPOT
				var c = closestSpot(start.x, start.y);

				if (c > -1) {
					console.log(c);
					if (spots[c] == undefined) {
						//console.log(spots[c]);
						//Check to see who's turn it is...
						if (xTurn) { //X TURN
							spots[c] = 1;
							xMoves.unshift(c);
							xTurn = false;

						} else { //O TURN
							spots[c] = 0; //SET THE SPOT
							oMoves.unshift(c); //TRACK THE MOVE
							xTurn = true; //SWAP TO OTHER PLAYERS TURN
						}
					} else {
						console.log(xMoves[xMoves.length-1]);
						//Let's see if we can add in a way to save the last space by selecting it again....hm
						if (xTurn && c == xMoves[xMoves.length-1]) { //Let x keeps it's space
							spots[c] = 1;
							xMoves.unshift(c);
							xTurn = false;
						} else if (!xTurn && c == oMoves[oMoves.length-1]) { //Let o keep its place.
                            spots[c] = 0; //SET THE SPOT
                            oMoves.unshift(c); //TRACK THE MOVE
                            xTurn = true; //SWAP TO OTHER PLAYERS TURN
						}
					}
				}
			}
			start.x = -1;
		} else {
			if (Date.now() > winTimer) {
				resetGame();
			}
		}
    }
	animate();
	</script>
</body>
</html>