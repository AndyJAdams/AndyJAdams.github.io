<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Make42</title>
	<style type="text/css">
		body{
            margin: 0;
            touch-action: none;
            position: fixed;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
        }
        canvas{
            touch-action: none;
            background-color: #DDD;
        }
	</style>
</head>
<body id='body'>
<canvas></canvas>
	<script>
	var canvas = document.querySelector('canvas');
    function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	}
	var ctx = canvas.getContext('2d');
    scaleCanvas();

    var selection = [];

    function Unit(x,y,w,h,val,r,c){
        this.x = x; this.y=y; this.w = w;this.h = h; this.val = val;
        this.r = r; this.c = c; this.used = false; this.flag = false;
        this.dx = 0; 
        this.draw = function(){
            if(this.flag){
                ctx.fillStyle='#444';
            } else {
                ctx.fillStyle='#b4b4b4';
            }

            if(this.dx >= this.w){
                ctx.fillRect(this.x, this.y,this.w, this.h);

                ctx.fillStyle='#444';
                if(this.flag){
                    ctx.fillStyle='#ddd';
                }
                ctx.textAlign='center';
                ctx.textBaseline = 'middle';
                ctx.font = 'Bold 30px Helvetica';
                ctx.fillText(this.val,this.x+this.w/2,this.y+this.h/2);
            } else {
                ctx.fillRect(this.x+this.w/2-this.dx/2,this.y+this.h/2-this.dx/2,this.dx, this.dx);
            }
        }

        this.update = function(){
            
            if(this.dx < this.w*2){
                this.dx+= ((this.w*1.2)-this.dx)/4;
            }
            this.draw();
        }

        this.reset = function(){
            this.val = Math.floor((Math.random()-0.25))*42;
            this.dx = 0; 
        }
    }

    var grid = [];
    function buildGrid(){
        for(var i = 0; i < 8; i++){
            var row = [];
            for(var j = 0; j < 8; j++){
                row.push(new Unit(i*55+30,j*55+130,50,50,Math.floor((Math.random()-0.25)*42),j,i));
            }
            grid.push(row);
        }
    }
    var solution = undefined;
    function makeSolution(){
        if(solution != undefined){
            return solution;
        }
        let formula = [];
        let steps = Math.floor(Math.random()*4)+2;
        //Choose a random starting unit
        let last = getRandomUnit();
        var retrycount = 0;
        if(last != null){
            last.used = true;
            formula.push(last.val);
            //For the set number of steps build a formula
            //TODO: Convert this into a format that works for PEMDAS
            for(let i = 0; i < steps; i++){
                let n = getNeighbor(last.r,last.c);
                if(n.length > 0){
                    //Select a random neighbor
                    let randN = Math.floor(Math.random()*n.length);
                    if(!n[randN].used){ //Make sure we haven't used it yet
                        formula.push(n[randN].val); //update formula
                        last = n[randN]; //set cycle vars
                        n[randN].used = true; //Set use case
                    } else {
                        if(retrycount < 2){
                            retrycount++;
                            i--; //try again we used this one already
                        } else {
                            break; //We're done chasing this... just leave
                        }
                    }
                } else {
                    break;
                }
            }
            //Total up the formula
            solution = 0;
            for(let j = 0; j < formula.length;j++){
                solution += parseInt(formula[j]);
            }
            //Clear all use flags
            for(let a = 0; a < grid.length; a++){
                for(let b = 0; b < grid[a].length; b++){
                    grid[a][b].used = false;
                }
            }
            return solution;
        } else {
            return undefined;
        }
    }

    function getNeighbor(r,c){
        let n = [];
        if(r > 0){ //UP
            n.push(grid[c][r-1]);
        } 
        if(c < grid.length-1){ //RIGHT
            n.push(grid[c+1][r]);
        }
        if(r < grid[c].length-1){ //DOWN
            n.push(grid[c][r+1]);
        }
        if(c > 0){
            n.push(grid[c-1][r]);
        }
        return n;
    }

    function getRandomUnit(){
        if(grid.length > 0){
            let randX = Math.floor(Math.random()*grid.length);
            let randY = Math.floor(Math.random()*grid[randX].length);
            return grid[randX][randY];
        } else {
            return null;
        }
    }

    
    //*************************************************
    //*************************************************
	function animate(){
		window.requestAnimationFrame(animate);
		ctx.clearRect(0,0,innerWidth,innerHeight);

        if(grid.length < 1){
            buildGrid();
            makeSolution();
        }

        if(selection.length > 0){
            ctx.beginPath();
            ctx.moveTo(selection[0].x+selection[0].w/2,selection[0].y+selection[0].h/2);
            for(var i = 1; i < selection.length; i++){
                ctx.lineTo(selection[i].x+selection[i].w/2,selection[i].y+selection[i].h/2);
            }
            ctx.strokeStyle='#444';
            ctx.lineWidth = selection[0].w;
            ctx.stroke();
            ctx.closePath();
        }

        ctx.textAlign = 'left';
        ctx.textBaseline = 'bottom';
        ctx.fillStyle='#444';
        ctx.font = 'Bold 56px Helvetica';
        ctx.fillText('Make',30,120);
        ctx.fillRect(175,55,30+grid.length*55-170,52);

        ctx.fillStyle='#ddd';
        ctx.fillText(''+solution,180,121);

        
        for(var i = 0; i < grid.length; i++){
            for(var j = 0; j < grid[i].length; j++){
                grid[i][j].update();
            }
        }
	}
    //*************************************************
    //*************************************************

    function checkSelection(x,y){
        for(var i = 0; i < grid.length; i++){
            for(var j = 0; j < grid.length; j++){
                let u = grid[i][j];
                if(x > u.x && x < u.x+u.w && y > u.y && y < u.y+u.h){
                    return u;
                }
            }
        }
        return null;
    }

	//*** INPUT SECTION **//
    window.addEventListener('keyup',function(e){
        console.log(e.keyCode);
    });

    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        scaleCanvas();
    });


    window.addEventListener('mousedown',inputStart,false);
    window.addEventListener('mousemove',inputMove,false);
    window.addEventListener('mouseup',inputEnd,false);

    window.addEventListener('touchstart',inputStart, false);
    window.addEventListener('touchmove', inputMove,false);
    window.addEventListener('touchcancel',inputEnd,false);
    window.addEventListener('touchend',inputEnd,false);

    var start = {x:-1,y:-1};
	var current = {x:-1,y:-1};
    function inputStart(evt){
        evt.preventDefault();
        if(evt.changedTouches != undefined){
            var touches = evt.changedTouches;
            if(touches.length > 0){
                start.x = touches[0].pageX;
                start.y = touches[0].pageY;
            }
        } else {
            start.x = evt.pageX;
            start.y = evt.pageY;
        }
				current.x = start.x;
				current.y = start.y;
    }

    function inputMove(evt){
        evt.preventDefault();
        if(start.x > -1){
            if(evt.changedTouches != undefined){
                var touches = evt.changedTouches;
                if(touches.length > 0){
                    current.x = touches[0].pageX;
                    current.y = touches[0].pageY;
                }
            } else {
                current.x = evt.pageX;
                current.y = evt.pageY;
            }
            //Are we over a unit 
            let unit = checkSelection(current.x, current.y);
            if(unit != null){
                if(selection.length > 0){
                    //Check if the unit was the last one we checked
                    if(unit != selection[selection.length-1]){
                        //Check if the unit is already in selection
                        let existing = -1;
                        for(var s = 0; s < selection.length; s++){
                            if(selection[s]==unit){
                                //Matching index
                                existing = s;
                                break;
                            }
                        }
                        if(existing > -1){ //We found a pre-matching unit.. cut off excess
                            selection = selection.splice(0,existing);
                        } else {
                            //Is the new unit a neighbor of the old one?
                            var neighbors = getNeighbor(selection[selection.length-1].r,selection[selection.length-1].c);
                            for(var n = 0; n < neighbors.length; n++){
                                if(neighbors[n] == unit){
                                     //New unit to add to selection
                                    selection.push(unit);
                                    unit.flag = true;
                                }
                            }
                           
                        }

                    }
                } else {
                    selection.push(unit);
                    unit.flag = true;
                }
                //Update selection units and non-seleciton units
                for(var i = 0; i < grid.length; i++){
                    for(var j = 0; j < grid[i].length;j++){
                        var t = grid[i][j];
                        var marked = false;
                        for(var s = 0; s < selection.length;s++){
                            if(selection[s] == t){
                                marked = true;
                            }
                        }
                        if(!marked){
                            t.flag = false;
                        } else {
                            t.flag = true;
                        }
                    }
                }
            }
        }
    }

    
    function inputEnd(){
        start.x = -1;
        //Grab all of the selected units values
        let total = 0;
        for(var i = 0; i < selection.length; i++){
            total += parseInt(selection[i].val);
            selection[i].flag = false;
        }
        console.log("TOT: "+total + " ? " + solution);
        if(total == solution){
            solution = undefined;
            makeSolution();
            console.log("WIN?");
        }
        selection = [];
    }
	animate();
	</script>
</body>
</html>
