<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>4OUT</title>
	<style type="text/css">
		body{
            margin: 0;
            touch-action: none;
            position: fixed;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
        }
        canvas{
            touch-action: none;
            background-color: #efefef;
        }
	</style>
</head>
<body id='body'>
	<canvas id='canvas'></canvas>
	<script>
    //Global Variables Here
    var DEBUG = true;
    var version = 0.0005;
    var dragSensitivity = 15;
    var grid = {x:4,y:6};
    var tileScale = {x:0,y:0};
    
    var tiles = [];
    var selected = [];
    var collections = [];
    var positions = [];

    var min = 10000000; var max = -1;

	var canvas = document.getElementById('canvas');	
    function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
        tileScale.x = innerWidth/grid.x;
        tileScale.y = innerHeight/grid.y;
        scaleGrid();
	}
	var ctx = canvas.getContext('2d');

    var colorArray = ["#F8B195","#F67280","#C06C84","#6C5B7B","#355C7D","#2A363B","#A8A7A7"];
        
    function Position(x,y){
        this.x = x; this.y = y;
    }
        
    function Collection(tiles){
        this.tiles = tiles;
        this.boundaries = {minX:1000000,maxX:-1,minY:1000000,maxY:-1};
        this.getBoundaries = function(){
            for(var i = 0; i < tiles.length; i++){
                if(tiles[i].x < this.boundaries.minX){
                    this.boundaries.minX = tiles[i].x;
                }
                if(tiles[i].x+tileScale.x > this.boundaries.maxX){
                    this.boundaries.maxX = tiles[i].x+tileScale.x;
                }
                if(tiles[i].y < this.boundaries.minY){
                    this.boundaries.minY = tiles[i].y;
                }
                if(tiles[i].y+tileScale.y > this.boundaries.maxY){
                    this.boundaries.maxY = tiles[i].y+tileScale.y;
                }
            }
        }
    }
        
	function Tile(x,y,w,h,gx,gy,t){
        this.x = x; this.y = y;
        this.w = w; this.h = h;
        this.gx = gx; this.gy = gy; this.t = t;
        this.dx = 0; this.dy = 0;
        this.owner = undefined;
        this.draw=function(){
            ctx.fillStyle=colorArray[this.t];
            ctx.fillRect(this.x-this.dx,this.y-this.dy,this.w+1,this.h+1);
            //roundRect(ctx,this.x+5,this.y+5,this.w-10,this.h-10,this.w/10,colorArray[this.t]);
            
            
            
            if(DEBUG){
                ctx.fillStyle='#FFF';
                ctx.font = '14px sans-serif';
                ctx.fillText(this.gx+","+this.gy + " T: " + this.t,this.x+25,this.y+26);
                
                if(this.owner != undefined){
                    ctx.strokeStyle='#FFF';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.x+this.w/2,this.y+this.h/2);
                    ctx.lineTo(this.owner.x+this.w/2,this.owner.y+this.h/2);
                    ctx.stroke();
                    ctx.closePath();
                }
            }
        }
        
        this.update = function(){
            getConnected(this);
            this.draw();
        }
    }
        
    function buildGrid(){
        positions = [];
        for(let i=0; i < grid.x; i++){
            var column = []; var pos = [];
            for(let j = 0; j < grid.y; j++){
                column.push(new Tile(i*tileScale.x,j*tileScale.y,tileScale.x,tileScale.y,i,j,Math.floor(Math.random()*colorArray.length)));
                pos.push(new Position(i*tileScale.x,j*tileScale.y));
            }
            tiles.push(column);
            positions.push(pos);
        }
    }
    
    function scaleGrid(){
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j<tiles[i].length; j++){
                var t = tiles[i][j];
                t.x = t.gx*tileScale.x;
                t.y = t.gy*tileScale.y;
                t.w = tileScale.x;
                t.h = tileScale.y;
                positions[i][j].x = i*tileScale.x;
                positions[i][j].y = j*tileScale.y;
            }
        }
    }
        
    function getConnected(a){
        var n = getNeighbors(a);
        var r = []; r.push(a);
        if(n.length > 0){
            for(var i = 0; i < n.length; i++){
                if(n[i].t == a.t){
                    if(n[i].owner == undefined){
                        var d = getConnected(n[i]);
                        for(var j = 0; j<d.length;j++){
                            r.push(d[j]);
                            d[j].owner = a;
                        }
                    } else {
                        a.owner = n[i].owner;
                        return r;
                    }
                }
            }
        } 
        return r;
    }

	function animate(){
		window.requestAnimationFrame(animate);
        ctx.clearRect(0,0,innerWidth,innerHeight);
        
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                tiles[i][j].update();
            }
        }
        
         if(start.x < 0){
            makeCollections();
        }
        
        if(tiles.length > 1){
            if(selected.length > 0 && DEBUG){
                for(var i= 0; i < selected.length;i++){
               ctx.fillStyle='#FFF'; ctx.fillRect(selected[i].x+tileScale.x-30,selected[i].y+25,10,10);
                    var r = getRowFromPoint(selected[i]);
                    ctx.fillStyle='#000';
                    for(var j = 0; j < r.length; j++){
                        ctx.fillRect(r[j].x+25,r[j].y+40,10,10);
                    }
                    var c = getColumnFromPoint(selected[i]);
                    ctx.fillStyle='#000';
                    for(var j = 0; j < c.length; j++){
                        ctx.fillRect(c[j].x+25,c[j].y+80,10,10);
                    }
                }
            }
            
            //Movement
            if(selected.length > 0 && dragDirection != -1){
                ctx.beginPath();
                ctx.moveTo(start.x,start.y);
                ctx.lineTo(current.x,current.y);
                ctx.stroke();
                for(var i = 0; i < selected.length; i++){
                    if(dragDirection == 0){
                        var dx = start.x-current.x;
                        if(selected[i].x-dx < min){
                          dx = selected[i].x-min;  
                        } 
                        if(selected[i].x+tileScale.x-dx > max){
                            dx = selected[i].x+tileScale.x-max;
                        }
                        selected[i].dx = dx;
                        var r = getRowFromPoint(selected[i]);
                        for(var j = 0; j < r.length; j++){
                            r[j].dx = dx;
                        }
                        ctx.beginPath();
                        ctx.moveTo(min, selected[0].y);
                        ctx.lineTo(max,selected[0].y);
                        ctx.lineWidth = 10;
                        ctx.strokeStyle='#F00';
                        ctx.stroke();
                    } else if(dragDirection == 1){
                        selected[i].dy = start.y-current.y;
                        var c = getColumnFromPoint(selected[i]);
                        for(var j = 0; j < c.length; j++){
                            c[j].dy = start.y-current.y;
                        }
                        ctx.beginPath();
                        ctx.moveTo(selected[0].x, min);
                        ctx.lineTo(selected[0].x,max);
                        ctx.lineWidth = 10;
                        ctx.strokeStyle='#0F0';
                        ctx.stroke();
                    }
                }
                
                
            } else {
                 for(var i = 0; i < tiles.length; i++){
                    for(var j = 0; j < tiles[i].length; j++){
                        tiles[i][j].dx = 0;
                        tiles[i][j].dy = 0;
                        tiles[i][j].x = positions[i][j].x;
                        tiles[i][j].y = positions[i][j].y;
                    }
                }
            }
            
            
        } else {
            buildGrid();
        }
        
       
	}
        
    //*** GAMEPLAY HELPERS ***//
    function getNeighbors(t){
        var n = [];
        if(t.gx+1 < grid.x){//RIGHT
            n.push(tiles[t.gx+1][t.gy]);
        }
        if(t.gy+1 < grid.y){ //DOWN
            n.push(tiles[t.gx][t.gy+1]);
        }
        return n;
    }
        
    function makeCollections(){
        collections = [];
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                if(getCollection(tiles[i][j]) < 0){
                    var o = getOwned(tiles[i][j]);
                    if(o.length > 1){
                        collections.push(new Collection(o));
                    }
                }
            }
        }
    }
        
    function getCollection(t){
        for(var i = 0; i < collections.length; i++){
            for(var j = 0; j < collections[i].tiles.length; j++){
                if(collections[i].tiles[j] == t){
                    return i;
                }
            }
        }
        return -1;
    }
        
    function getSelected(x,y){
        for(var i = 0; i < tiles.length;i++){
            for(var j = 0; j < tiles[i].length;j++){
                 var t = tiles[i][j];
                if(x > t.x && x < t.x+t.w && y > t.y && y < t.y+t.h){
                    return getOwned(t);
                }
            }
        }
        return [];
    }
        
    function getOwned(a){
        if(a.owner != undefined){
            a = a.owner;
        }
        var o = []; o.push(a);
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                if(tiles[i][j].owner == a){
                   o.push(tiles[i][j]); 
                }
            }
        }
        return o;
    }
        
    function getRowFromPoint(t){ //t = tile we are checking against 
        var row = [];
        for(var i = t.gx-1; i > -1; i--){ //Left
            if(getCollection(tiles[i][t.gy]) != -1){
                break;
            } else {
                row.push(tiles[i][t.gy]);
            }
        }
        for(var i =t.gx+1; i < grid.x; i++){
            if(getCollection(tiles[i][t.gy])!= -1){
                break;   
            } else {
                row.push(tiles[i][t.gy]);
            }
        }
        return row;
    }
        
    function getColumnFromPoint(t){
        var col = [];
        for(var i = t.gy-1; i> -1; i--){
            if(getCollection(tiles[t.gx][i]) != -1){
                break;
            } else {
                col.push(tiles[t.gx][i]);
            } 
        }
        for(var i = t.gy+1; i < grid.y; i++){
            if(getCollection(tiles[t.gx][i]) != -1){
                break;
            } else {
                col.push(tiles[t.gx][i]);
            }
        }
        return col;
    }

	//*** INPUT SECTION **//
    var start = {x:-1,y:-1};
    var current = {x:-1,y:-1};
    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        scaleCanvas();
    });
    window.addEventListener('mousedown',inputStart,false);
    window.addEventListener('mousemove',inputMove,false);
    window.addEventListener('mouseup',inputEnd,false);

    window.addEventListener('touchstart',inputStart, false);
    window.addEventListener('touchmove', inputMove,false);
    window.addEventListener('touchcancel',inputEnd,false);
    window.addEventListener('touchend',inputEnd,false);
    
    function inputStart(evt){
        evt.preventDefault();
        if(evt.changedTouches != undefined){
            var touches = evt.changedTouches;
            if(touches.length > 0){
                start.x = touches[0].pageX;
                start.y = touches[0].pageY;
            }
        } else {
            start.x = evt.pageX;
            start.y = evt.pageY;
        }
        selected = getSelected(start.x,start.y);
    }
    
    var dragDirection = -1;
    function inputMove(evt){
        evt.preventDefault();
        if(start.x > -1){
            if(evt.changedTouches != undefined){
                var touches = evt.changedTouches;
                if(touches.length > 0){
                    current.x = touches[0].pageX;
                    current.y = touches[0].pageY;
                }
            } else {
                current.x = evt.pageX;
                current.y = evt.pageY;
            }
            
            //Movement code here
            //Get the desired direction of movement
             if(selected.length > 0 && dragDirection == -1){
                var xdif = Math.abs(start.x-current.x);
                var ydif = Math.abs(start.y-current.y);
                 if(xdif > dragSensitivity || ydif > dragSensitivity){ //Check
                     if(xdif > ydif){//Horizontal 
                         dragDirection = 0;
                         //HERE - limit movement
                     } else if(ydif > xdif){ //Vertical
                         dragDirection = 1;
                     } else { //Ignore
                         dragDirection = -1;
                     }
                 }
            }
            console.log(min+" to "+max);
        }
    }
    
    function inputEnd(){
        start.x = -1;
        selected = [];
        dragDirection = -1;
        //Snap moving tiles to nearest position
        //Clear movement direction and selection
        min = 10000000;
        max = -1;
    }

    /*** GENERAL FUNCTIONS ***/
    function contains(arr,obj){
        for(var i = 0; i < arr.length; i++){
            if(arr[i] == obj){
                return true;
            }
        }
        return false;
    }
        
    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof stroke === 'undefined') {
        stroke = false;
      }
      if (typeof radius === 'undefined') {
        radius = 5;
      }
      if (typeof radius === 'number') {
        radius = {tl: radius, tr: radius, br: radius, bl: radius};
      } else {
        var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
        for (var side in defaultRadius) {
          radius[side] = radius[side] || defaultRadius[side];
        }
      }
      ctx.beginPath();
      ctx.moveTo(x + radius.tl, y);
      ctx.lineTo(x + width - radius.tr, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      ctx.lineTo(x + width, y + height - radius.br);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
      ctx.lineTo(x + radius.bl, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
      ctx.lineTo(x, y + radius.tl);
      ctx.quadraticCurveTo(x, y, x + radius.tl, y);
      ctx.closePath();
      if (fill) {
        ctx.fill();
      }
      if (stroke) {
        ctx.stroke();
      }
        
     
    }

    scaleCanvas();
	animate();
        
    /*TODO LIST
    -1. Get affected column and row after selection
    2. Detect movement direction
    3. Move tile(s) accordingly
        3.a Single tiles can wrap, larger groups cannot
        3.b Tiles should slide together as one unit, and follow the input pointer on the selected axis of movement
        3.c larger groups will need to move the entire collection accross all rows or columns. **THIS WILL BE PARTICULARLY TRICKY**
    */
	</script>
</body>
</html>