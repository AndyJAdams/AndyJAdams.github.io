<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>4OUT</title>
	<style type="text/css">
		body{
            margin: 0;
            touch-action: none;
            position: fixed;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
        }
        canvas{
            touch-action: none;
            background-color: #efefef;
        }
	</style>
</head>
<body id='body'>
	<canvas id='canvas'></canvas>
	<script>
    //Global Variables Here
    var DEBUG = false;
    var version = 0.0001;
    var grid = {x:4,y:6};
    var tileScale = {x:0,y:0};
    
    var tiles = [];
    var selected = [];
    var collections = [];


	var canvas = document.getElementById('canvas');	
    function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
        tileScale.x = innerWidth/grid.x;
        tileScale.y = innerHeight/grid.y;
        scaleGrid();
	}
	var ctx = canvas.getContext('2d');

    var colorArray = ["#F8B195","#F67280","#C06C84","#6C5B7B","#355C7D","#2A363B","#A8A7A7"];
        
	function Tile(x,y,w,h,gx,gy,t){
        this.x = x; this.y = y;
        this.w = w; this.h = h;
        this.gx = gx; this.gy = gy; this.t = t;
        this.owner = undefined;
        this.draw=function(){
            ctx.fillStyle=colorArray[this.t];
            //ctx.fillRect(this.x,this.y,this.w+1,this.h+1);
            //function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            roundRect(ctx,this.x+5,this.y+5,this.w-10,this.h-10,this.w/10,colorArray[this.t]);
            
            
            
            if(DEBUG){
                ctx.fillStyle='#FFF';
                ctx.font = '14px sans-serif';
                ctx.fillText(this.gx+","+this.gy + " " + this.t,this.x+25,this.y+26);
                
                if(this.owner != undefined){
                    ctx.strokeStyle='#FFF';
                    ctx.beginPath();
                    ctx.moveTo(this.x+this.w/2,this.y+this.h/2);
                    ctx.lineTo(this.owner.x+this.w/2,this.owner.y+this.h/2);
                    ctx.stroke();
                    ctx.closePath();
                }
            }
        }
        
        this.update = function(){
            getConnected(this);
            this.draw();
        }
    }
        
    function buildGrid(){
        for(let i=0; i < grid.x; i++){
            var column = [];
            for(let j = 0; j < grid.y; j++){
                column.push(new Tile(i*tileScale.x,j*tileScale.y,tileScale.x,tileScale.y,i,j,Math.floor(Math.random()*colorArray.length)));
            }
            tiles.push(column);
        }
    }
    
    function scaleGrid(){
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j<tiles[i].length; j++){
                var t = tiles[i][j];
                t.x = t.gx*tileScale.x;
                t.y = t.gy*tileScale.y;
                t.w = tileScale.x;
                t.h = tileScale.y;
            }
        }
    }
        
    function getConnected(a){
        var n = getNeighbors(a);
        var r = []; r.push(a);
        if(n.length > 0){
            for(var i = 0; i < n.length; i++){
                if(n[i].t == a.t){
                    if(n[i].owner == undefined){
                        var d = getConnected(n[i]);
                        for(var j = 0; j<d.length;j++){
                            r.push(d[j]);
                            d[j].owner = a;
                        }
                    } else {
                        a.owner = n[i].owner;
                        return r;
                    }
                }
            }
        } 
        return r;
    }

	function animate(){
		window.requestAnimationFrame(animate);
        ctx.clearRect(0,0,innerWidth,innerHeight);
        
         if(start.x < 0){
            makeCollections();
        }
        
        if(tiles.length > 1){
            for(var i = 0; i < tiles.length; i++){
                for(var j = 0; j < tiles[i].length; j++){
                    tiles[i][j].update();
                }
            }
            
            
            if(selected.length > 0){
                for(var i= 0; i < selected.length;i++){
               ctx.fillStyle='#FFF'; ctx.fillRect(selected[i].x+tileScale.x-30,selected[i].y+25,10,10);
                    var r = getRowFromPoint(selected[i]);
                    ctx.fillStyle='#000';
                    for(var j = 0; j < r.length; j++){
                        ctx.fillRect(r[j].x+25,r[j].y+40,10,10);
                    }
                    var c = getColumnFromPoint(selected[i]);
                    ctx.fillStyle='#000';
                    for(var j = 0; j < c.length; j++){
                        ctx.fillRect(c[j].x+25,c[j].y+80,10,10);
                    }
                }
                
            }
        } else {
            buildGrid();
        }
        
       
	}
        
    //*** GAMEPLAY HELPERS ***//
    function getNeighbors(t){
        var n = [];
        if(t.gx+1 < grid.x){//RIGHT
            n.push(tiles[t.gx+1][t.gy]);
        }
        if(t.gy+1 < grid.y){ //DOWN
            n.push(tiles[t.gx][t.gy+1]);
        }
        return n;
    }
        
    function makeCollections(){
        collections = [];
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                if(getCollection(tiles[i][j]) < 0){
                    var o = getOwned(tiles[i][j]);
                    if(o.length > 1){
                        collections.push(o);
                    }
                }
            }
        }
    }
        
    function getCollection(t){
        for(var i = 0; i < collections.length; i++){
            for(var j = 0; j < collections[i].length; j++){
                if(collections[i][j] == t){
                    return i;
                }
            }
        }
        return -1;
    }
        
    function getSelected(x,y){
        for(var i = 0; i < tiles.length;i++){
            for(var j = 0; j < tiles[i].length;j++){
                 var t = tiles[i][j];
                if(x > t.x && x < t.x+t.w && y > t.y && y < t.y+t.h){
                    return getOwned(t);
                }
            }
        }
        return [];
    }
        
    function getAffected(){
        var row = {max:grid.x,min:-1};
        var col = {max:grid.y,min:-1};
        //Stretch out from each of the selected tiles.
        for(var i = 0; i < selected.length; i++){
            //Check to the right
            
        }
    }
        
    function getOwned(a){
        if(a.owner != undefined){
            a = a.owner;
        }
        var o = []; o.push(a);
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                if(tiles[i][j].owner == a){
                   o.push(tiles[i][j]); 
                }
            }
        }
        return o;
    }
        
    function getRowFromPoint(t){ //t = tile we are checking against 
        var row = [];
        for(var i = t.gx-1; i > -1; i--){ //Left
            if(getCollection(tiles[i][t.gy]) != -1){
                break;
            } else {
                row.push(tiles[i][t.gy]);
            }
        }
        for(var i =t.gx+1; i < grid.x; i++){
            if(getCollection(tiles[i][t.gy])!= -1){
                break;   
            } else {
                row.push(tiles[i][t.gy]);
            }
        }
        return row;
    }
        
    function getColumnFromPoint(t){
        var col = [];
        for(var i = t.gy-1; i> -1; i--){
            if(getCollection(tiles[t.gx][i]) != -1){
                break;
            } else {
                col.push(tiles[t.gx][i]);
            } 
        }
        for(var i = t.gy+1; i < grid.y; i++){
            if(getCollection(tiles[t.gx][i]) != -1){
                break;
            } else {
                col.push(tiles[t.gx][i]);
            }
        }
        return col;
    }

	//*** INPUT SECTION **//
    var start = {x:-1,y:-1};
    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        scaleCanvas();
    });
    window.addEventListener('mousedown',inputStart,false);
    window.addEventListener('mousemove',inputMove,false);
    window.addEventListener('mouseup',inputEnd,false);

    window.addEventListener('touchstart',inputStart, false);
    window.addEventListener('touchmove', inputMove,false);
    window.addEventListener('touchcancel',inputEnd,false);
    window.addEventListener('touchend',inputEnd,false);
    
    function inputStart(evt){
        evt.preventDefault();
        if(evt.changedTouches != undefined){
            var touches = evt.changedTouches;
            if(touches.length > 0){
                start.x = touches[0].pageX;
                start.y = touches[0].pageY;
            }
        } else {
            start.x = evt.pageX;
            start.y = evt.pageY;
        }
        selected = getSelected(start.x,start.y);
    }
    
    function inputMove(evt){
        evt.preventDefault();
        var x = -1; var y = -1;
        if(start.x > -1){
            if(evt.changedTouches != undefined){
                var touches = evt.changedTouches;
                if(touches.length > 0){
                    x = touches[0].pageX;
                    y = touches[0].pageY;
                }
            } else {
                x = evt.pageX;
                y = evt.pageY;
            }
        }
    }
    
    function inputEnd(){
        start.x = -1;
        selected = [];
    }

    /*** GENERAL FUNCTIONS ***/
    function contains(arr,obj){
        for(var i = 0; i < arr.length; i++){
            if(arr[i] == obj){
                return true;
            }
        }
        return false;
    }
        
    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
      if (typeof stroke === 'undefined') {
        stroke = false;
      }
      if (typeof radius === 'undefined') {
        radius = 5;
      }
      if (typeof radius === 'number') {
        radius = {tl: radius, tr: radius, br: radius, bl: radius};
      } else {
        var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
        for (var side in defaultRadius) {
          radius[side] = radius[side] || defaultRadius[side];
        }
      }
      ctx.beginPath();
      ctx.moveTo(x + radius.tl, y);
      ctx.lineTo(x + width - radius.tr, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
      ctx.lineTo(x + width, y + height - radius.br);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
      ctx.lineTo(x + radius.bl, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
      ctx.lineTo(x, y + radius.tl);
      ctx.quadraticCurveTo(x, y, x + radius.tl, y);
      ctx.closePath();
      if (fill) {
        ctx.fill();
      }
      if (stroke) {
        ctx.stroke();
      }
        
     
    }

    scaleCanvas();
	animate();
        
    /*TODO LIST
    1. Get affected column and row after selection
    2. Detect movement direction
    3. Move tile(s) accordingly
        3.a Single tiles can wrap, larger groups cannot
        3.b Tiles should slide together as one unit, and follow the input pointer on the selected axis of movement
        3.c larger groups will need to move the entire collection accross all rows or columns. **THIS WILL BE PARTICULARLY TRICKY**
    4. Detect tile collections of 4 or more
    5. Remove tile collections of 4 or more
    6. Drop tiles appropriately, but do NOT break apart larger groups??
    */
	</script>
</body>
</html>