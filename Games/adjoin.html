<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>ADJOIN</title>
	<style type="text/css">
		body{
            margin: 0;
            touch-action: none;
            position: fixed;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
        }
        canvas{
            touch-action: none;
            background-color: #F4F7FA;
        }
	</style>
</head>
<body id='body'>
	<canvas id='canvas'></canvas>
	<script>
	//User adjustable variables
	var DEBUG = true;
	var grid = {x:4,y:4};
	var spacing = 1;
	var dragSensitivity = 50;

	//System controlled variables
	var tileScale = {x:0,y:0};
	var units = [];
	var pts = [];
	var palette = ['#EC5565','#F26E53','#6798D0','#FFCE55','#58C1A6','#E788B8'];
	var selection = undefined;
	var dragDirection = -1;
	var affected = [];

	var canvas = document.getElementById('canvas');	
	function Point(x,y){this.x = x; this.y = y;}

    function scaleCanvas(){
    	
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	}

	var ctx = canvas.getContext('2d');

	function Rect(x,y,w,h){this.x = x; this.y = y; this.w = w; this.h = h;}

	function Unit(rects,val,selOff){
		this.rects = rects;
		this.val = val;
		this.selectionOffset = selOff;

		this.draw = function(){
			
			for(var i = 0; i < this.rects.length; i++){
				ctx.fillStyle=palette[this.val];
				ctx.fillRect(this.rects[i].x+this.selectionOffset, this.rects[i].y+this.selectionOffset, this.rects[i].w-(this.selectionOffset*2), this.rects[i].h-(this.selectionOffset*2));
				// if(i > 0){ //We have more than 1 rect
				// 	ctx.fillStyle='#000';
				// 	if(Math.abs(this.rects[i-1].x-this.rects[i].x) < 5){ //Rects line up vertically
				// 		if(this.rects[i].y < this.rects[i-1].y){
				// 			//This rect on top
				// 			ctx.fillRect(this.rects[i].x,this.rects[i].y+tileScale.y-10,tileScale.x-4,20);
				// 		} else {
				// 			ctx.fillRect(this.rects[i-1].x, this.rects[i-1].y+tileScale.y-10,tileScale.x-4, 20);
				// 		}

				// 	}
				// 	if(Math.abs(this.rects[i-1].y-this.rects[i].y) < 5){
				// 		if(this.rects[i].x < this.rects[i-1].x){
				// 			//This rect left
				// 			ctx.fillRect(this.rects[i].x+tileScale.x-10,this.rects[i].y,20,tileScale.y-4);
				// 		} else {
				// 			ctx.fillRect(this.rects[i-1].x+tileScale.x-10,this.rects[i-1].y,20,tileScale.y-4);
				// 		}
				// 	}
				// }
			}

			//Loop through rects and draw connectors
			if(this.rects.length > 1){
				for(var i = 0; i < this.rects.length; i++){
					var me = this.rects[i];
					for(var j = 0; j < this.rects.length; j++){
						if(this.rects[j] != me){
							if(Math.abs(this.rects[j].x-me.x) < 5 && Math.abs(this.rects[j].y-me.y) < tileScale.y+(tileScale.y/2)){
								var top = me;
								if(this.rects[j].y < me.y){
									top = this.rects[j];
								}
								ctx.fillRect(top.x+this.selectionOffset,top.y+tileScale.y-(this.selectionOffset*2),tileScale.x-(this.selectionOffset*2),this.selectionOffset*4);
							}
							if(Math.abs(this.rects[j].y-me.y) < 5&& Math.abs(this.rects[j].x-me.x) < tileScale.x+(tileScale.x/2)){
								var left = me;
								if(this.rects[j].x < me.x){
									left = this.rects[j];
								}
								ctx.fillRect(left.x+tileScale.x-(this.selectionOffset*2),left.y+this.selectionOffset,this.selectionOffset*4,tileScale.y-(this.selectionOffset*2));
							}
						}
					}
				}
			}

			//Colorblind Accessibility
			//Here we want to make an indication in the upper left most corner of the unit. 
			//First we find the upper-left most rect
			var upperMost = -1;
			var top = innerHeight; var left = innerWidth;
			for(var i = 0; i < this.rects.length; i++){
				if(this.rects[i].y < top ){
					upperMost = i;
					top = this.rects[i].y;
					left = this.rects[i].x;
				} else if(this.rects[i].y == top){
					if(this.rects[i].x < left){
						upperMost = i;
						top = this.rects[i].y;
						left = this.rects[i].x;
					}
				}
			}

			ctx.fillStyle='#F4F7FA';
			ctx.strokeStyle='#F4F7FA';
			/*
			switch(this.val){
				case 0:
					// ctx.lineWidth=4;
					// ctx.strokeRect(this.rects[upperMost].x+10,this.rects[upperMost].y+10,20,20);
					break;

				case 1:
					ctx.beginPath();
					ctx.moveTo(this.rects[upperMost].x+10,this.rects[upperMost].y+10);
					ctx.lineTo(this.rects[upperMost].x+30,this.rects[upperMost].y+10);
					ctx.lineTo(this.rects[upperMost].x+10,this.rects[upperMost].y+30);
					ctx.closePath();
					ctx.fill();
					break;
				case 2:
					ctx.beginPath();
					ctx.moveTo(this.rects[upperMost].x+10,this.rects[upperMost].y+10);
					ctx.lineTo(this.rects[upperMost].x+30,this.rects[upperMost].y+10);
					ctx.lineTo(this.rects[upperMost].x+30,this.rects[upperMost].y+30);
					ctx.closePath();
					ctx.fill();
					break;
				case 3:
					ctx.beginPath();
					ctx.moveTo(this.rects[upperMost].x+30,this.rects[upperMost].y+10);
					ctx.lineTo(this.rects[upperMost].x+30,this.rects[upperMost].y+30);
					ctx.lineTo(this.rects[upperMost].x+10,this.rects[upperMost].y+30);
					ctx.closePath();
					ctx.fill();
					break;
				case 4:
					ctx.beginPath();
					ctx.moveTo(this.rects[upperMost].x+10,this.rects[upperMost].y+10);
					ctx.lineTo(this.rects[upperMost].x+30,this.rects[upperMost].y+30);
					ctx.lineTo(this.rects[upperMost].x+10,this.rects[upperMost].y+30);
					ctx.closePath();
					ctx.fill();
					break;
				case 5:
					ctx.fillRect(this.rects[upperMost].x+10,this.rects[upperMost].y+10,20,20);
					break;
				default:
					break;

			}
			
			*/
			if(DEBUG){
				//Do debug output here for the unit
			}
		}

		this.update = function(){
			this.draw();
		}

		this.addRects = function(r){
			for(var i = 0; i < r.length; i++){
				this.rects.push(r[i]);
			}
		}
	}

	//var timeStep = Date.now()+5000;
	function animate(){
		window.requestAnimationFrame(animate);
		ctx.clearRect(0,0,innerWidth,innerHeight);

		if(units.length > 0){
			var uniqueUnits = [];
        	for(var i = 0; i < units.length; i++){
        		for(var j = 0; j < units[i].length; j++){
        			if(selection != undefined){
        				if(units[i][j] == selection){
        					units[i][j].selectionOffset = spacing*4;
        				} else {
        					units[i][j].selectionOffset = spacing;
        				}
        			}
        			units[i][j].update();
        			if(!uniqueUnits.includes(units[i][j])){
        				uniqueUnits.push(units[i][j]);
        			}
        		}
        	}
        	if(start.x == -1){
	        	combineUnits();
	        } else {
	        	//Let's handle the movement of dragging here
	        	if(dragDirection == -1){//We've not yet determined the drag direction
	        		var xDif = Math.abs(current.x-start.x);
	        		var yDif = Math.abs(current.y-start.y);
	        		if(xDif > dragSensitivity || yDif > dragSensitivity){
	        			if(xDif > yDif){ //Horizontal
	        				if(current.x > start.x){
	        					dragDirection = 1;
	        				} else if(current.x < start.x){
	        					dragDirection = 3;
	        				}
	        			} else { //Vertical
	        				if(current.y > start.y){
	        					dragDirection = 2;
	        				} else {
	        					dragDirection = 0;
	        				}
	        			}
	        			getAffected();
	        		}
	        	} else {
	        		ctx.fillStyle='#FFF';
	        		ctx.font = '32px sans-serif';
	        		ctx.fillText(dragDirection, 20,60);
	        		//We have a drag direction and should also have a list of effected units
	        		switch(dragDirection){
	        			case 0: //UP
	        				break;
	        			case 1: //RIGHT
	        				break;
	        			case 2: //DOWN
	        				break;
	        			case 3: //LEFT
	        				break;
	        			default:
	        				break;
	        		}
	        	}
	        }
        	// if(Date.now() > timeStep){
        	// 	timeStep = Date.now()+5000;
        	// 	buildGrid();
        	// }
        } else {
        	buildGrid();
        }

	}

	//*** GAMEPLAY FUNCTIONS **//
	function buildGrid(){
		grid.x = Math.floor(Math.random()*4)+2;
    	grid.y = Math.floor(Math.random()*4)+3;

    	tileScale.x = innerWidth/grid.x;
		tileScale.y = innerHeight/grid.y;
		pts = [];
		for(var i = 0; i< grid.x; i++){
			var col = [];
			for(var j = 0; j < grid.y; j++){
				col.push(new Point(i*tileScale.x,j*tileScale.y));
			}
			pts.push(col);
		}

		units = [];
		for(var i = 0; i < grid.x; i++){
			var col = [];
			for(var j = 0; j < grid.y; j++){
				var r = new Rect(i*tileScale.x,j*tileScale.y,tileScale.x, tileScale.y);
				var rects = [];
				rects.push(r);
				var v = Math.floor(Math.random()*palette.length);
				col.push(new Unit(rects,v,spacing));
			}
			units.push(col);
		}
	}

	function getAffected(){
		if(selection == undefined){
			return;
		}
		//So we'll need to figure out how to stretch outward from the unit 
		//We could just go through each unit space that is inside selection and ignore the current unit

		if(dragDirection == 0 || dragDirection == 2){ //Vertical

		} else {//Horizontal
		}
	}

	function combineUnits(){
		for(var i = 0; i < grid.x; i++){
			for(var j = 0; j < grid.y; j++){
				if(j-1 > -1){//UP
					if(units[i][j] != units[i][j-1] && units[i][j].val == units[i][j-1].val){
						units[i][j-1].addRects(units[i][j].rects);
						units[i][j] = units[i][j-1];
						//console.log("uC:"+i+","+j+" to "+i+","+(j-1));
						break;
					}
				} 
				if(j+1 < grid.y){//DOWN
					if(units[i][j] != units[i][j+1] && units[i][j].val == units[i][j+1].val){
						units[i][j+1].addRects(units[i][j].rects);
						units[i][j] = units[i][j+1];
						//console.log("dC:"+i+","+j+" to "+i+","+(j+1));
						break;
					}
				}
				if(i-1 > -1){//LEFT
					if(units[i-1][j] != units[i][j] && units[i-1][j].val == units[i][j].val){
						units[i-1][j].addRects(units[i][j].rects);
						units[i][j] = units[i-1][j];
						//console.log("uC:"+i+","+j+" to "+(i-1)+","+j);
						break;
					}
				} 
				if(i+1 < grid.x){//RIGHT
					if(units[i+1][j] != units[i][j] && units[i+1][j].val == units[i][j].val){
						units[i+1][j].addRects(units[i][j].rects);
						units[i][j] = units[i+1][j];
						//console.log("uC:"+i+","+j+" to "+(i+1)+","+j);
						break;
					}
				}
			}
		}
	}

	function getDistance(x1, y1, x2, y2){
		return Math.abs(Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2)));
	}

	function makeSelection(x,y){
		for(var i = 0; i < units.length; i++){
			for(var j = 0; j < units[i].length; j++){
				for(var k = 0; k < units[i][j].rects.length; k++){
					var rect = units[i][j].rects[k];
					if(x > rect.x && x < rect.x+rect.w&& y > rect.y && y < rect.y+rect.h){
						return units[i][j];
					}
				}
			}
		}
		return undefined;
	}

	function clearSelection(){
		for(var i = 0; i < units.length; i++){
			for(var j = 0; j < units[i].length; j++){
				units[i][j].selectionOffset = spacing;
			}
		}
		selection = undefined;
	}
	
	//*** INPUT SECTION **//
    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        scaleCanvas();
    });
    
    
    window.addEventListener('mousedown',inputStart,false);
    window.addEventListener('mousemove',inputMove,false);
    window.addEventListener('mouseup',inputEnd,false);

    window.addEventListener('touchstart',inputStart, false);
    window.addEventListener('touchmove', inputMove,false);
    window.addEventListener('touchcancel',inputEnd,false);
    window.addEventListener('touchend',inputEnd,false);
    
    var start = {x:-1,y:-1};
    var current = {x:-1,y:-1};
    function inputStart(evt){
        evt.preventDefault();
        if(evt.changedTouches != undefined){
            var touches = evt.changedTouches;
            if(touches.length > 0){
                start.x = touches[0].pageX;
                start.y = touches[0].pageY;
            }
        } else {
            start.x = evt.pageX;
            start.y = evt.pageY;
        }
        selection = makeSelection(start.x,start.y);
        current.x = start.x;
        current.y = start.y;
    }
    
    function inputMove(evt){
        evt.preventDefault();
        var x = -1; var y = -1;
        if(start.x > -1){
            if(evt.changedTouches != undefined){
                var touches = evt.changedTouches;
                if(touches.length > 0){
                    current.x = touches[0].pageX;
                    current.y = touches[0].pageY;
                }
            } else {
                current.x = evt.pageX;
                current.y = evt.pageY;
            }
        }
    }
    
    function inputEnd(){
        start.x = -1;
        start.y = -1;
        current.x = -1;
        current.y = -1;
        dragDirection = -1;
        clearSelection();
    }


    
    scaleCanvas();
	animate();

	/* Notes
	AA- 5/1/20 - 10:57
	Setting up selections so I can determine which block has been selected. From here we figure out drag direction and start the cycle. This should be fun

	Once I have the selected unit. I'll need to locate all of its rows and columns in the units array so I can then scan outward to find the possible affected units. This will also have to take into account array bounds and runing into other units with more than 1 rect. 

	If I want the large units to push other large units, I'll then need to add all of it's affected rows/columns to the list of affected. Of course then I can't let that affected unit cycle so it becomes our new limit for cycling. Wow that will be a headache. 

	Of course I could just say that large units can't push other large units. Or base it off of the count, so a unit with 2 rects can only be pushed units with 2 or more rects. So a 3 unit could push a two but not vise versa. That might seem non-intuitive to the user. I think keeping it absolute on or off would read better, and off is much simpler to maintain. We'll see what happens. 

	AA- 4/29/20 - 13:20
	Should the larger tiles be allowed to break apart via wrapping? If we allow them to break apart via drag the game is too easy. 

	If we allow them to break apart via wrapping then why not dragging?

	Should we allow smaller tiles to push larger masses? There is a posibility for a cascading affect... 

	Should only the single tile be allowed to cycle?

	I think realistically the only way to answer these questions is to prototype each system iteratively and see what plays well. 

	Also due to a lack of interface we'll need the rule set to be clearly demonstrated or displayed via juicy feedback to the player. 
	So for example if a collection gets pushed to an edge it should bounce / jiggle to signifiy non-compliance. If a collection hits another collection it should bounce the collided collection? 

	What ever the end result is... it needs to be clear. 
	Remember that the ultimate goal here is good puzzle design, but ideally a zero interface game would be satisfying. Well, to me it would be. :)

	*/
	</script>
</body>
</html>