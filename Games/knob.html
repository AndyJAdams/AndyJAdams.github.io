<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>KNOB</title>
	<style type="text/css">
		body{
            margin: 0;
            touch-action: none;
            position: fixed;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
        }
        canvas{
            touch-action: none;
            background-color: #ddd;
        }
	</style>
</head>
<body id='body'>
	<canvas id='canvas'></canvas>
	<script>
        
        /* TODO: Make the targets appear only on the rings
                        Make the keys appear only on the rings
                        Limit the keys to ring boundaries

                        USE location.search to access all after the ? in the current URL we can then parse out the designed level. if the parser returns blank... load a default level from a list of levels. :)
        */
    var color1 = '#ddd';
    var color2 = '#222';
    var angleDiff = 0;
    var rotationSensitivity = 10;
    var ringCount = 2;
    
        
	var canvas = document.getElementById('canvas');	
    function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	}
	var ctx = canvas.getContext('2d');
        
    function Ring(radius,startDeg,endDeg,targetAngle, keyAngle,gauge){ 
        this.targetRadius = radius;
        this.dotScale = 7.20;
        this.keyScale = 9.20;
        this.radius = 0; 
        this.start = startDeg; this.end = endDeg;
//        this.limits = {min: dtr(this.start), max:dtr(this.end)};
//        if(this.end < this.start){
//            this.limits.min = this.end; this.limits.max = this.start;
//        }
        this.gauge = gauge;
        
        this.posArray = [];
        
        this.defineRingArray = function(){
            this.posArray = [];
            var min = this.start; var max = this.end;
            if(this.end < this.start){
                min = this.end; max = this.start;
            }
            for(var i = min; i < max; i+=0.5){
                var x = this.targetRadius*Math.cos(dtr(i))+innerWidth/2;
                var y = this.targetRadius*Math.sin(dtr(i))+innerHeight/2;
                this.posArray.push(new Position(x,y));
            }
            console.log(this.posArray);
        }
        
        //Build array of available key positons
        this.defineRingArray();

        this.keyAngle = dtr(keyAngle);
            //this.limits.min+(Math.random()*(this.limits.max-this.limits.min));
        //Get default random positions for the key
        this.keyX = this.targetRadius*Math.cos(this.keyAngle)+innerWidth/2;
        this.keyY = this.targetRadius*Math.sin(this.keyAngle)+innerHeight/2;
        
        //Find the closest point in postion array for the key
//        this.closestX = innerWidth; this.closestY = innerHeight;
        this.distance = 10000000;
        this.keyIndex = -1;
        for(var i = 0; i < this.posArray.length; i++){
            var dist = getDistance(this.posArray[i].x, this.posArray[i].y,this.keyX,this.keyY);
            if(dist < this.distance){
                this.distance = dist;
                this.keyIndex = i;
            }
//            if(Math.abs(posArray.x-this.keyX)<this.closestX){
//                if(Math.abs(posArray[i].y-this.keyY)<this.closestY){
//                    this.closestX = Math.abs(posArray[i].x-this.keyX);
//                    this.closestY = Math.abs(posArray[i].y-this.keyY);
//                    this.keyIndex = i;
//                }
//            }
        }
        if(this.keyIndex > -1){
            this.keyX = this.posArray[this.keyIndex].x;
            this.keyY = this.posArray[this.keyIndex].y;
        }
        console.log(this.keyIndex +" @ "+ this.distance);
        
        this.dotAngle = dtr(targetAngle);
        this.dotX = this.targetRadius*Math.cos(this.dotAngle)+innerWidth/2;
        this.dotY = this.targetRadius*Math.sin(this.dotAngle)+innerHeight/2;
        
        //Asset radii
        this.dotRadius = 0;
        this.keyRadius = 0;
        
        this.draw = function(){
            ctx.setLineDash([]);
            ctx.lineWidth = this.gauge;
            
            //Draw the limiting ring
            if(this.radius > 1){
                ctx.beginPath();
                ctx.arc(innerWidth/2,innerHeight/2,this.radius,dtr(this.start), dtr(this.end));
                ctx.strokeStyle=color2;
                ctx.stroke();
                ctx.closePath();
            }
            //Here we draw the circle keys
            if(this.keyRadius > 1){
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.keyX, this.keyY,this.keyRadius,0,2*Math.PI);
                ctx.fillStyle = color1;
                ctx.fill();
                ctx.stroke();
            }
            //Here we draw the black dot "Target"
            if(this.dotRadius > 1){
                ctx.beginPath();
                ctx.arc(this.dotX,this.dotY,this.dotRadius,0,2*Math.PI);
                ctx.fillStyle=color2;
                ctx.fill();
                ctx.closePath();
            }
            
            ctx.strokeRect(this.closestX-100, this.closestY-100, 200,200);
        }
        
        this.update = function(radDiff){
            //Update key angle within bounds of posArray
            if(this.keyIndex > -1){
                if(radDiff > 0){
                    this.keyIndex += this.gauge/rotationSensitivity;
                } else if(radDiff < 0){
                    this.keyIndex -= this.gauge/rotationSensitivity;
                }
                if(this.keyIndex < 0){
                    this.keyIndex = 0;
                } else if(this.keyIndex > this.posArray.length-1){
                    this.keyIndex = this.posArray.length-1;
                }
                this.keyX = this.posArray[Math.round(this.keyIndex)].x;
                this.keyY = this.posArray[Math.round(this.keyIndex)].y;
            }
            
            if(gameOver){
                if(this.dotRadius > 1){
                    this.dotRadius-= 0.5;
                } else if(this.keyRadius > 1){
                    this.keyRadius -= 0.8;
                } else if(this.radius > 1){
                    this.radius -= (this.radius/10);
                } 
            } else {
                if(this.radius < this.targetRadius){
                    this.radius+= this.targetRadius/10;
                } else if(this.dotRadius < this.dotScale){
                    this.dotRadius+= this.dotScale/10;
                } else if(this.keyRadius < this.keyScale){
                    this.keyRadius += this.keyScale/10;
                }
            }
            this.draw();
        }
    }
        
    function Position(x,y){
        this.x = x; 
        this.y = y;
    }
    
    var rings = [];
    function buildRings(){
        var data = getData();
        if(data.length > 0){
            //Here we have data from the URL
            for(var i = 0; i < data.length; i++){
                if(data[i] != undefined){
                    var s = data[i][0];
                    var e = data[i][1];
                    var t = data[i][2];
                    var k = data[i][3];
                    var w = data[i][4];
                    
                    rings.push(new Ring(i*50+50,s,e,t,k,w));
                } else {
                    //Do nothing for empty ring..
                }
            }
        } else {
            //Here we do not have URL data. 
            ringCount = 2;
            for(var i  =0; i < ringCount; i++){
                var start = dtr(Math.random()*240);
                var end = start+dtr(Math.random()*100+50);
                var target = dtr(0.5*(end-start));
                var key = dtr(0.75*(end-start));
                var width = 2;
                rings.push(new Ring(i*40+50,start,end,target,key,2));
            }
            console.log("Loaded trash data");
        }
        

    }
        
    function getData(){
        var raw = location.search;
        var ringData = [];
        if(raw == ""){
           return ringData;
        } else {
            //Parse out the level data
            //EXAMPLE - ?level=1.7_-0.6_2.3_-1.3_2/u/-1.9_1.7_1.2_-1.6_2/2.4_-2.7_2.7_-3_2/u
            var rawSplit = raw.split('=');
            var data = rawSplit[1].split('/');
            for(var i = 0; i < data.length; i++){
                if(data[i] == "u"){
                    ringData.push(undefined);
                } else {
                    var r = data[i].split('_');
                    for(var j = 0; j < r.length;j++){
                        r[j] = parseFloat(r[j]);
                    }
                    ringData.push(r);
                }
            }
        }
        return ringData;
    }
    //**********************************************************
    var gameOver = false;
	function animate(){ //Game Draw Loop
		window.requestAnimationFrame(animate);
		ctx.clearRect(0,0,innerWidth,innerHeight);
        ctx.fillStyle=color1;
        ctx.fillRect(0,0,innerWidth,innerHeight);
        if(rings.length < 1){
            buildRings();
        }
        if(current.x > -1 && !gameOver){
            if(angle.current != angle.prev){
                //angleDiff = angle.prev-angle.current;
                angleDiff = start.angle-angle.current;
                if(angleDiff > 350){
                   angleDiff -= 360;
                } else if(angleDiff < -300){
                    angleDiff += 360;
                }
                angle.prev = angle.current;
            }
            
            ctx.beginPath();
            ctx.moveTo(innerWidth/2, innerHeight/2);
            ctx.lineTo(current.x,current.y);
            ctx.stroke();
            ctx.closePath();
            
            var dist = getDistance(innerWidth/2, innerHeight/2,current.x,current.y);
            var radStart = dtr(start.angle);
            var radCurr = dtr(angle.current);
            if(radStart > radCurr){
                var placeholder = radCurr;
                radCurr = radStart; 
                radStart = placeholder;
            }
            ctx.beginPath();
            ctx.arc(innerWidth/2,innerHeight/2,dist,radStart, radCurr);
                    ctx.setLineDash([5,7]);
            ctx.stroke();
        } else {
            angleDiff = 0;
        }
        
        for(var i  =0; i < rings.length; i++){
            rings[i].update(dtr(angleDiff));
        }
        
        if(validatePuzzle() && !gameOver){
            gameOver = true;
        }
        
        if(gameOver){
            respawn();
        }
	}
        
    //***********************************************************
    
    function respawn(){
         for(var i= 0; i < rings.length; i++){
             if(rings[i].radius > 1){
                 return false;
             }
         }
        rings = [];
        gameOver = false;
    }
        
    function validatePuzzle(){
        for(var i= 0; i < rings.length; i++){
            var dist = getDistance(rings[i].dotX,rings[i].dotY,rings[i].keyX, rings[i].keyY);
            if(dist > 5 || Math.abs(rings[i].radius-rings[i].targetRadius) > 5){
                return false;
            }
        }
        return true;
    }
        
    // USE SOHCAHTOA
    // Sine = Opposite (b) / Hypotenuse (c)
    // Cos = Adjacent(a)/Hypotenuse (c)
    // Tan = Opposite (b)/Adjacent(a);

    function findAngle(x,y){
        var dx = x-innerWidth/2;
        var dy = y-innerHeight/2;
        var angle = Math.atan2(dy, dx)*(180/Math.PI);
        if(angle < 0){
            angle = 360+angle;
        }
        return angle;
    }
        
    function rtd(a){ //Radians To Degrees
        return a*(180/Math.PI);
    }
        
    function dtr(a){ //Degrees To "Pure" Radians
        return a*(Math.PI/180);
    }
        
    function posXFromAngle(r,a){
       return r*Math.cos(a)+innerWidth/2;
    }
        
    function posYFromAngle(r,a){
        return r*-Math.sin(a)+innerHeight/2;
    }
        
    function getRadains(x1,y1,x2,y2){
        return Math.atan2(y2-y1,x2-x1);
    }
        
    function getDegrees(x1,y1,x2,y2){
        return getRadians(x1,y1,x2,y2)*180/Math.PI;
    }
        
    function getDistance(x1,y1,x2,y2){
        var x = Math.pow(Math.abs(x1-x2),2);
        var y = Math.pow(Math.abs(y1-y2),2);
        return Math.sqrt(x+y);
    }
    
	//*** INPUT SECTION **//
    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        scaleCanvas();
    });
    
    
    window.addEventListener('mousedown',inputStart,false);
    window.addEventListener('mousemove',inputMove,false);
    window.addEventListener('mouseup',inputEnd,false);

    window.addEventListener('touchstart',inputStart, false);
    window.addEventListener('touchmove', inputMove,false);
    window.addEventListener('touchcancel',inputEnd,false);
    window.addEventListener('touchend',inputEnd,false);
    var angle = {prev: 0, current:0};
    var start = {x:-1,y:-1,angle:0};
    var current = {x:-1,y:-1};
    function inputStart(evt){
        evt.preventDefault();
        if(evt.changedTouches != undefined){
            var touches = evt.changedTouches;
            if(touches.length > 0){
                start.x = touches[0].pageX;
                start.y = touches[0].pageY;
            }
        } else {
            start.x = evt.pageX;
            start.y = evt.pageY;
            angle.prev = findAngle(start.x, start.y);
            start.angle = angle.prev;
            angle.current = angle.prev;
        }
        
        if(start.x < 20 && start.y < 20){
            for(var i = 0; i < rings.length; i++){
                rings[i].keyAngle = rings[i].dotAngle;
                rings[i].offsetSolution(spin);
            }
        }
    }
    
    function inputMove(evt){
        evt.preventDefault();
        var x = -1; var y = -1;
        if(start.x > -1){
            if(evt.changedTouches != undefined){
                var touches = evt.changedTouches;
                if(touches.length > 0){
                   current.x = touches[0].pageX;
                    current.y = touches[0].pageY;
                }
            } else {
                current.x = evt.pageX;
                current.y = evt.pageY;
                angle.current = findAngle(current.x,current.y);
                
                
            }
        }
    }
    
    function inputEnd(){
        start.x = -1;
        current.x = -1;
    }
    
    scaleCanvas();
	animate();
		
		/*
		https://gist.github.com/conorbuck/2606166
		*/
	</script>
</body>
</html>
