<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>VURM</title>
	<style type="text/css">
		body{
            margin: 0;
            touch-action: none;
            position: fixed;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
             
        }
        #canvas{
            touch-action: none;
            position: absolute;
            top: 0;
            left:0;
        }
        
	</style>
</head>
<body id='body'>
    <script src='https://alca.sfo2.cdn.digitaloceanspaces.com/tmijs/1.4.2/tmi.min.js'></script>
    <script id='vurmchat' src='./vurmchat.js'></script>
	<canvas id='canvas'></canvas>
    <img id='kap' src='./Emotes/Kappa.png'>
    <img id='pog' src='./Emotes/Pog.png'>
    <img id='lul' src='./Emotes/Lul.png'>
	<script>
    var kap = document.getElementById('kap');
    var pog = document.getElementById('pog');
    var lul = document.getElementById('lul');
    
	var canvas = document.getElementById('canvas');	
    function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	}
	var ctx = canvas.getContext('2d');
        
    //GLOBAL VARIABLES
    var primaryColor = '#dddddd';
    var invertedColor = '#222222';
    var moveSpeed = 3.5;
    var direction = -1;
    var startLength = 10;
    var nextVurm = 50;
    var vurms = [];
    var begin = false;
    var score = 0;
    var gameOver = false;
    var bgColor = '#222222';
    var timeOut = 0;
    var startTime = 0;
    var bestScore = 0;
    
    var defaultBlockSpeed = 1;
    var currentBlockSpeed = 1;

    //OBJECT DEFINITION
    function Point(x,y){
        this.x = x; this.y = y;
    }
        
    function Vurm(len,points){
        this.len=len; this.points = points;
        
        this.draw = function(){
            ctx.lineWidth = innerWidth/35+5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle=primaryColor;
            if(inverted){
                ctx.strokeStyle=invertedColor;
            }
            ctx.beginPath();
            ctx.moveTo(this.points[0].x, this.points[0].y)
            for(var i = 1; i < this.len; i++){
                if(Math.abs(this.points[i].x-this.points[i-1].x) > innerWidth/2 || Math.abs(this.points[i].y-this.points[i-1].y) > innerHeight/2){
                    ctx.moveTo(this.points[i].x, this.points[i].y);
                } else {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
            }
            ctx.stroke();
        }
        
        this.update = function(){
            if(direction > -1){
                if(!begin){
                    begin = true;
                    startTime = Date.now();
                }
                var x = this.points[0].x; 
                var y = this.points[0].y;
                switch(direction){
                    case 0: //Up
                        y-= moveSpeed;
                        break;
                    case 1: //Right
                        x+= moveSpeed;
                        break;
                    case 2: //Down
                        y+= moveSpeed;
                        break;
                    case 3: //Left
                        x-= moveSpeed;
                        break;
                    default:
                        break;
                }
                //Wrap the vurm if it goes off the edge
                if(x < -1){
                    x = innerWidth;
                } else if(x > innerWidth+1){
                    x = 0;
                }
                if(y < -1){
                    y = innerHeight;
                } else if(y > innerHeight+1){
                    y = 0;
                }
                //Update a new point to the vurm
                var np = new Point(x,y);
                //Check for self collision
                for(var i =  0; i < this.points.length;i++){
                    if(this.points[i].x == np.x && this.points[i].y == np.y){
                        //COLLISION
                        if(i < this.len){
                            this.cut(i);
                            break;
                        }
                    }
                }
                this.points.unshift(np);
                //Make sure we're only storing enough points for use
                if(this.points.length > this.len+20){
                    this.points.pop();
                }
            }
            
            if(this.len >= startLength){
                this.draw();
            } else {
                removeVurm(this);
            }
        }
        
        this.cut = function(index, start=false){
            if(index < this.len){  //Can't cut off what isn't there 
                //First let's cut the length of the vurm
                if(!start){ //from this point backwards
                    var toEnd = Math.abs(index-this.len);
                    this.len -= toEnd;
                    this.points.splice(index,toEnd);
                } else {
                    var half = Math.floor(this.len/2);
                    this.len -= half;
                    this.points.splice(0,half);    
                }
                var audio = new Audio('./Audio/Umph.mp3');
                audio.play();
            }
        }
    }
        
    function Fruit(x,y,r){
        this.x = x; this.y = y; this.r = r;
        this.draw = function(){
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r,0,2*Math.PI);
            ctx.fillStyle=primaryColor;
            if(inverted){
                ctx.fillStyle=invertedColor;
            }
            ctx.fill();
        }
        
        this.update=function(){
            //Check for vurm collision
            for(var i = 0; i < vurms.length; i++){
                if(getDist(this.x, this.y, vurms[i].points[0].x, vurms[i].points[0].y) < this.r+(this.r/2)){
                    //COLLISION
                    vurms[i].len+= 10;
                    effects.push(new RingEffect(this.x, this.y,this.r));
                    //score++;
                    var audio = new Audio('./Audio/Knock.wav');
                    audio.play();
                    this.reset();
                    break;
                }
            }
            
            this.draw();
        }
        
        this.reset = function(){
            this.x = Math.random()*(innerWidth-40)+20;
            this.y = Math.random()*(innerHeight-40)+20;
        }
        
    }
        
    function Obstacle(x,y,w,h,tx,ty){
        this.sx = x; this.sy  = y;
        this.x = x; this.y=y; this.w = w; this.h = h;
        this.tx = tx; this.ty = ty;
        this.bounce = false;
        
        this.draw = function(){
            ctx.lineWidth = 2;
            ctx.strokeStyle=primaryColor;
            if(inverted){
                ctx.strokeStyle=invertedColor;
            }
            ctx.strokeRect(this.x, this.y, this.w, this.h);
//            ctx.fillStyle=bgColor;
//            ctx.fillRect(this.x, this.y, this.w, this.h);
        }
        
//        this.drawFiller = function(){
//            ctx.fillStyle='#ddd';
//            ctx.fillRect(this.x+5, this.y+5, this.w-10, this.h-10);
//        }
        
        this.update = function(){
            if(direction > -1){
                if(!this.bounce){
                    if(this.x < this.tx){
                        this.x+=currentBlockSpeed;
                    } else if(this.x > this.tx){
                        this.x-=currentBlockSpeed;
                    }
                    if(this.y < this.ty){
                        this.y+=currentBlockSpeed;
                    } else if(this.y > this.ty){
                        this.y-=currentBlockSpeed;
                    }

                    if(getDist(this.x, this.y, this.tx, this.ty)< 4*currentBlockSpeed){
                        this.bounce = true;
                    }
                } else {
                    if(this.x < this.sx){
                        this.x+=currentBlockSpeed;
                    } else if(this.x > this.sx){
                        this.x-=currentBlockSpeed;
                    }
                    if(this.y < this.sy){
                        this.y+=currentBlockSpeed;
                    } else if(this.y > this.sy){
                        this.y-currentBlockSpeed;
                    }
                    if(getDist(this.x,this.y, this.sx, this.sy) < 12){
                        this.bounce = false;
                    }
                }
            }
            this.draw();
        }
    }
        
    function RingEffect(x,y,r){
        this.x = x; this.y = y; this.r = r;
        this.w = 5;
        
        this.draw = function(){
            ctx.strokeStyle=primaryColor+'88';
            if(inverted){
                ctx.strokeStyle=invertedColor+'88';
            }
            ctx.lineWidth = this.w;
            ctx.beginPath();
            ctx.arc(this.x,this.y,this.r,0,2*Math.PI);
            ctx.stroke();
        }
        
        this.update = function(){
            this.r++;
            this.w -= 0.02;
            if(this.w > 0.02){
                this.draw();
            } else {
                removeEffect(this);
            }
        }
    }
        
    function Dot(x,y,r){
        this.x =x; this.y=y; this.r = r;
        this.c= randColor();
        this.gr = Math.random()*2+0.1;
        this.draw=function(){
            ctx.beginPath();
            ctx.arc(this.x, this.y,this.r,0,2*Math.PI);
            ctx.fillStyle = '#'+this.c;
            ctx.fill();
        }
        
        this.update=function(){
            this.r+=this.gr;
            this.draw();
        }
    }
        
    function Emote(type, time){
        this.type = type; this.time = time;
        this.x = Math.random()*innerWidth-100;
        this.y = Math.random()*innerHeight-100;
        this.scale = Math.random() * innerHeight/2 + 100;
        this.draw = function(){
            if(this.time > Date.now()){
                switch(this.type){
                    case 0: //Kappa
                        ctx.drawImage(kap,0,0,473,473,this.x,this.y,this.scale,this.scale);
                        break;
                    case 1: //LUL
                        ctx.drawImage(lul,0,0,512,512,this.x,this.y,this.scale,this.scale);
                        break;
                    case 2: //POG
                        ctx.drawImage(pog,0,0,200,200,this.x,this.y,this.scale,this.scale);
                        break;
                    default:
                        break;
                }
            } else {
                removeEmote(this);
            }
        }
    }
        
    //OBJECT DECLARATION
    function makeStartVurm(){
            var pts = [];
            for(var i = 0; i < startLength; i++){
                pts.push(new Point(innerWidth/2,innerHeight/2+(i*moveSpeed)));
            }
            vurms.push(new Vurm(startLength,pts));
    }
    
    var obs = [];
    obs.push(new Obstacle(100,100,innerWidth/5,innerHeight/20,innerWidth-100-innerWidth/5,100));
        obs.push(new Obstacle(innerWidth-100-innerWidth/5,innerHeight-200,innerWidth/5,innerHeight/20,100,innerHeight-200));
    obs.push(new Obstacle(80,300,innerWidth/40,innerHeight-600,innerWidth/2-80-innerWidth/40,300));
    obs.push(new Obstacle(innerWidth-80-innerWidth/40,300,innerWidth/40,innerHeight-600,innerWidth/2+80,300));
    obs.push(new Obstacle(innerWidth-140-innerWidth/30,(innerHeight/10*9)-innerHeight/4,innerWidth/30,innerHeight/4,innerWidth-140-innerWidth/30,innerHeight/10));
    obs.push(new Obstacle(140,(innerHeight/10*9)-innerHeight/4,innerWidth/30,innerHeight/4,140,innerHeight/10));
    obs.push(new Obstacle(innerWidth/2-(innerWidth/20)/2,-20,innerWidth/20,150,innerWidth/2-(innerWidth/20)/2,-20));
    obs.push(new Obstacle(innerWidth/2-(innerWidth/20)/2,innerHeight-150,innerWidth/20,150,innerWidth/2-(innerWidth/20)/2,innerHeight-150));
    obs.push(new Obstacle(-20,innerHeight/2-(innerHeight/20)*2,150,innerHeight/20,-20,innerHeight/2-(innerHeight/20)*2));
    obs.push(new Obstacle(innerWidth-150,innerHeight/2-(innerHeight/20)*2,150,innerHeight/20,innerWidth-150,innerHeight/2-(innerHeight/20)*2));
    
        
    var fruits = [];
    fruits.push(new Fruit(innerWidth/2,innerHeight/2-200,10));
    var f1 = new Fruit(innerWidth/2,innerHeight/2-200,10);
        f1.reset();
        fruits.push(f1);
    var f2 = new Fruit(innerWidth/2,innerHeight/2-200,10);
        f2.reset();
        fruits.push(f2);
    
    var dots = [];
    var effects = [];
    function removeEffect(e){
        for(var i = 0; i< effects.length; i++){
            if(effects[i]==e){
                effects.splice(i,1);
                break;
            }
        }
    }
    var emotes = [];
        
    var speedTimeOut = 0;
    var invTimeOut = 0;
    //******************************************************************
    //******************************************************************
    //var bgoffset = 0;
    var lastUser = '';
	function animate(){
		window.requestAnimationFrame(animate);
		ctx.clearRect(0,0,innerWidth,innerHeight);
        
        if(messages.length > 0){
            for(var i =  0; i< messages.length; i++){
                if(!messages[i].shown){
                    if(messages[i].cheer && Date.now()>timeOut){
                        //SOMEONE CHEERED... DO SUMPTIN
                        for(var i = 0; i< 20;i++){
                            var x = Math.random()*innerWidth;
                            var y = Math.random()*innerHeight;
                            var r = Math.random()*10+5;
                            dots.push(new Dot(x,y,r));
                        }
                        timeOut = Date.now()+parseInt(chatTimeOut);
                    } else {
                        //Broke ass message
                        var msg = messages[i].msg;
                        console.log(msg);
                        msg.toLocaleLowerCase();
                        if(msg.includes('!red') && redAllow){
                            bgColor = '#b22222';
                            var redAud = new Audio('./Audio/red.mp3');
                            redAud.play();
                        }
                        if(msg.includes('!blue') && blueAllow){
                            bgColor = '#15357A';
                            var blueAud = new Audio('./Audio/blue.mp3');
                            blueAud.play();
                        }
                        if(msg.includes('!green') && greenAllow){
                            bgColor = '#193207';
                            var gAud = new Audio('./Audio/green.mp3');
                            gAud.play();
                        }
                        //Increase speed of blocks
                        if(msg.includes('!fast') && fastAllow){
                                currentBlockSpeed *= 2;
                                if(currentBlockSpeed > 10){
                                    currentBlockSpeed = 10;
                                }
                                speedTimeOut = Date.now()+parseInt(chatTimeOut);
                                var fAud = new Audio('./Audio/fast.mp3');
                                fAud.play();
                            
                        } 
                        if(msg.includes('!slow') && slowAllow){
                                currentBlockSpeed = currentBlockSpeed/2;
                                if(currentBlockSpeed < 0.2){
                                    currentBlockSpeed = 0.2;
                                }
                                speedTimeOut = Date.now()+parseInt(chatTimeOut);
                                var sAud = new Audio('./Audio/slow.mp3');
                                sAud.play();
                        }
                        if(msg.includes('!derp') && derpAllow){
                                //Mess with player controls here
                                inverted = !inverted;
                                invTimeOut = Date.now()+parseInt(chatTimeOut);
                                var dAud = new Audio('./Audio/derp.mp3');
                                dAud.play();
                        }
                    }
                    
                    if(msg.includes('LUL')){
                        emotes.push(new Emote(1,Date.now()+10000));
                    }
                    if(msg.includes('Kappa')){
                        emotes.push(new Emote(0,Date.now()+10000));
                    }
                    if(msg.includes('PogChamp')){
                        emotes.push(new Emote(2, Date.now()+10000));
                    }
                    lastUser = messages[i].user;
                    messages[i].shown = true;
                }
            }
        }
        
        ctx.fillStyle=bgColor;
        if(bgColor == invertedColor && inverted){
            ctx.fillStyle=primaryColor;
        }
        ctx.fillRect(0,0,innerWidth,innerHeight);
        
        for(var i = 0; i < emotes.length;i++){
            emotes[i].draw();
        }
        
        var now = Date.now();
        if(now > timeOut){
            dots = [];
        } 
        
        if(now > speedTimeOut){
            currentBlockSpeed = defaultBlockSpeed;
        }
        
        if(now > invTimeOut){
            inverted = false;
        }

        if(chatAllow){
            ctx.fillStyle=primaryColor+'44';
            if(inverted){
                ctx.fillStyle = invertedColor+'44';
            }
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'left';
            for(var i = 0; i < messages.length; i++){
                ctx.fillText(messages[i].user+": "+messages[i].msg,20,innerHeight-20-i*50);
            }
        }

        for(var i = 0; i < dots.length; i++){
            dots[i].update();
        }
        
        for(var i = 0;i < effects.length; i++){
            effects[i].update();
        }
        
        for(var i = 0;i < obs.length; i++){
            obs[i].update();
        }
        
        //Draw vurms ***********************************>>>>>>>>>>>>>>>>>>>>
        for(var i = 0; i < vurms.length; i++){
            vurms[i].update();
            if(vurms[i] != undefined){
                if(vurms[i].len > nextVurm){
                    var x = Math.random()*innerWidth;
                    var y = Math.random()*innerHeight;
                    var pts = [];
                    for(var i = 0; i < 30; i++){
                        pts.push(new Point(x,y+(i*moveSpeed)));
                    }
                    vurms.push(new Vurm(30,pts));
                    nextVurm += 60;
                    var aud = new Audio('./Audio/Whup.mp3');
                    aud.play();
                }
            } 
        }
        
        for(var i = 0; i < fruits.length; i++){
            fruits[i].update();
        }
        
        detectCollisions();
        
        if(begin && !gameOver){
            ctx.fillStyle=primaryColor+'aa';
            if(inverted){
                ctx.fillStyle=invertedColor+'aa';
            }
            ctx.font='36px sans-serif';
            ctx.textAlign = 'center';
            score = Math.floor((Date.now()-startTime)/1000);
            ctx.fillText(score,40,50);
            if(bestScore > 0){
                ctx.textAlign = 'right';
                ctx.fillText("best: " + bestScore, innerWidth-40,50);
            }
        }
            
        if(begin && direction < 0 && !gameOver){
            ctx.fillStyle=primaryColor;
            if(inverted){
                ctx.fillStyle=invertedColor;
            }
            ctx.fillRect(innerWidth/2-innerWidth/4,innerHeight/2-innerHeight/4,innerWidth/2,innerHeight/2);
            ctx.fillStyle=invertedColor;
            if(inverted){
                ctx.fillStyle=primaryColor;
            }
            ctx.font = '72px sans-serif';
            ctx.textAlign = "center";
            ctx.fillText("PAUSED",innerWidth/2, innerHeight/2);
            ctx.font = '40px sans-serif';
            if(escaped){
                ctx.fillText('press esc to resume', innerWidth/2, innerHeight/2+60);
            } else {
                ctx.fillText('touch to resume', innerWidth/2, innerHeight/2+60);
            }
        }
        
        if(direction < 0 && gameOver && begin){
            ctx.fillRect(innerWidth/2-innerWidth/4,innerHeight/2-innerHeight/4,innerWidth/2,innerHeight/2);
            ctx.fillStyle='#222';
            ctx.font = '72px sans-serif';
            ctx.textAlign = "center";
            ctx.fillText(score,innerWidth/2, innerHeight/2);
            ctx.font = '40px sans-serif';
            if(escaped){
                ctx.fillText('press esc to restart', innerWidth/2, innerHeight/2+60);
            } else {
                ctx.fillText('Double Tap to restart', innerWidth/2, innerHeight/2+80);
            }
            ctx.fillText('FIN',innerWidth/2,innerHeight/2-80);
        }
        validateGame();
        
        //Display controls on screen
        if(!begin){
            ctx.font = '16px sans-serif';
            ctx.fillStyle=primaryColor;
            ctx.textAlign = 'center';
            ctx.fillText('DESKTOP',innerWidth/2-120,innerHeight/2-50);
            ctx.fillText('w',innerWidth/2-120,innerHeight/2);
            ctx.fillText('a',innerWidth/2-160,innerHeight/2+30);
            ctx.fillText('s',innerWidth/2-120,innerHeight/2+30);
            ctx.fillText('d',innerWidth/2-90,innerHeight/2+30);
            
            ctx.fillText('MOBILE',innerWidth/2+120,innerHeight/2-50);
            ctx.fillText('swipe',innerWidth/2+120,innerHeight/2);
            ctx.fillText('to move',innerWidth/2+120,innerHeight/2+30);
        }
	}
     
   var escaped = false;
    var touched = false;
    //******************************************************************
    //******************************************************************    
        
    //HELPER FUNCTIONS
    function randColor(){
       var c = Math.floor(Math.random()*16777215).toString(16);
        return c;
    }    
        
    function validateGame(){
        if(vurms.length < 1){
            gameOver = true;
            direction = -1;
        }
    }    
    
    function removeVurm(v){
        for(var i = 0; i < vurms.length; i++){
            if(vurms[i] == v){
                vurms.splice(i,1);
                break;
            }
        }
    }
        
    function removeEmote(e){
        for(var i = 0; i < emotes.length; i++){
            if(emotes[i] == e){
                emotes.splice(i,1);
                return;
            }
        }
    }    
        
    function getDist(x1,y1,x2,y2){
        return Math.abs(Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2)));
    }
        
    function detectCollisions(){
        for(var i = 0;i < vurms.length; i++){
            var v = vurms[i];
            //Now that we have the vurm let's check it against some boxes
            for(var j = 0; j < obs.length; j++){
                var ob = obs[j];
                var ox1 = ob.x; var oy1 = ob.y; var ox2 = ob.x+ob.w; var oy2 = ob.y+ob.h;
                //Now we have the limits for a box, lets check against points on the vurm
                for(var p = 0; p < v.points.length; p++){
                    var pt = v.points[p];
                    if(pt.x > ox1 && pt.x < ox2 && pt.y > oy1 && pt.y < oy2){
                        //The point is inside the box
                        if(p == 0){
                            v.cut(p,true);
                        } else {
                            v.cut(p);
                        }
                    }
                }
            }
        }
        
        //Check if fruit are inside obstacles
        for(var i = 0; i < fruits.length; i++){
            var f = fruits[i];
            //Check the obstacles
            for(var j = 0; j < obs.length; j++){
                var ob = obs[j];
                var ox1 = ob.x; var oy1 = ob.y; var ox2 = ob.x+ob.w; var oy2 = ob.y+ob.h;
                if(f.x > ox1-f.r && f.x < ox2+f.r && f.y > oy1-f.r && f.y < oy2+f.r){
                    //fruit is too close to box... reset it. 
                    f.reset();
                    break;
                }
            }
        }
    }

	//*** INPUT SECTION **//
    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        scaleCanvas();
    });
    
    var prevDir = -1;
    var lastPress = 0;
    var inverted = false;
    window.addEventListener('keydown', function(e){
        escaped = true;
        e.preventDefault();
        switch(e.key){
            case 'ArrowUp':
                if(!inverted){
                    if(direction != 2 && prevDir < 0){
                        direction = 0;
                    }
                } else {
                    if(direction != 0 && prevDir < 0){
                        direction = 2;
                    }
                }
                break;
            case 'w':
                if(!inverted){
                    if(direction != 2 && prevDir < 0){
                        direction = 0;
                    }
                } else {
                    if(direction != 0 && prevDir < 0){
                        direction = 2;
                    }
                }
                break;
            case 'ArrowDown':
                if(!inverted){
                    if(direction != 0 && prevDir < 0){
                        if(direction == -1){
                            direction = 0;
                        } else {
                            direction = 2;
                        }
                    }
                } else {
                    if(direction != 2 && prevDir < 0){
                        if(direction == -1){
                            direction = 0;
                        } else {
                            direction = 0;
                        }
                    }
                }
                break;
            case 's':
                if(!inverted){
                    if(direction != 0 && prevDir < 0){
                        if(direction == -1){
                            direction = 0;
                        } else {
                            direction = 2;
                        }
                    }
                } else {
                    if(direction != 2 && prevDir < 0){
                        if(direction == -1){
                            direction = 0;
                        } else {
                            direction = 0;
                        }
                    }
                }
                break;
            case 'ArrowLeft':
                if(!inverted){
                    if(direction != 1 && prevDir < 0){
                        direction = 3;
                    }
                } else {
                    if(direction != 3 && prevDir < 0){
                        direction = 1;
                    }
                }
                break;
            case 'a':
                if(!inverted){
                    if(direction != 1 && prevDir < 0){
                        direction = 3;
                    }
                } else {
                    if(direction != 3 && prevDir < 0){
                        direction = 1;
                    }
                }
                break;
            case 'ArrowRight':
                if(!inverted){
                    if(direction != 3 && prevDir < 0){
                        direction = 1;
                    }
                } else {
                    if(direction != 1 && prevDir < 0){
                        direction = 3;
                    }
                }
                break;
            case 'd':
                if(!inverted){
                    if(direction != 3 && prevDir < 0){
                        direction = 1;
                    }
                } else {
                    if(direction != 1 && prevDir < 0){
                        direction = 3;
                    }
                }
                break;
            case 'Escape':
                if(!gameOver){
                    if(prevDir < 0){
                        prevDir = direction;
                        direction = -1;
                        lastPress = Date.now();
                    } else {
                        if(Date.now() > lastPress+600){
                            direction = prevDir;
                            prevDir = -1;
                        }
                    }
                } else {
                    makeStartVurm();
                    score = 0;
                    if(score > bestScore){
                        bestScore = score;
                    }
                    gameOver = false;
                    begin = false;
                }
                break;
            default:
                break;
        }
    });
        
    window.addEventListener('mousedown',inputStart,false);
    window.addEventListener('mousemove',inputMove,false);
    window.addEventListener('mouseup',inputEnd,false);

    window.addEventListener('touchstart',inputStart, false);
    window.addEventListener('touchmove', inputMove,false);
    window.addEventListener('touchcancel',inputEnd,false);
    window.addEventListener('touchend',inputEnd,false);
    
    var start = {x:-1,y:-1};
    var current = {x:-1,y:-1};
    var tapTime = 0;
    function inputStart(evt){
        evt.preventDefault();
        if(evt.changedTouches != undefined){
            var touches = evt.changedTouches;
            if(touches.length > 0){
                touched = true;
                start.x = touches[0].pageX;
                start.y = touches[0].pageY;
                direction = prevDir;
                prevDir = -1;
                if(gameOver){
                    if(Date.now()-tapTime < 1000){
                        makeStartVurm();
                        score = 0;
                        gameOver = false;
                        begin = false;
                    } else {
                        tapTime = Date.now();
                    }
                }
            }
        } else {
            //No mouse controls on this one.
//            start.x = evt.pageX;
//            start.y = evt.pageY;
        }
    }
    
    function inputMove(evt){
        evt.preventDefault();
        var x = -1; var y = -1;
        if(start.x > -1){
            if(evt.changedTouches != undefined){
                var touches = evt.changedTouches;
                if(touches.length > 0){
                    current.x = touches[0].pageX;
                    current.y = touches[0].pageY;
                    //Now we check current agains previous (aka start)
                    if(getDist(current.x,current.y,start.x, start.y) > 30){
                        var xDif = Math.abs(current.x-start.x);
                        var yDif = Math.abs(current.y-start.y);
                        if(xDif > yDif){ //Horizontal
                            if(!inverted){
                                if(current.x > start.x && direction != 3){
                                    direction = 1;
                                } else if(current.x < start.x && direction != 1){
                                    direction = 3;
                                }
                            } else {
                                if(current.x > start.x && direction != 1){
                                    direction = 3;
                                } else if(current.x < start.x && direction != 3){
                                    direction = 1;
                                }
                            }
                        } else if(yDif > xDif){
                            if(!inverted){
                                if(current.y > start.y && direction != 0){
                                    direction = 2;
                                } else if(current.y < start.y && direction != 2){
                                    direction = 0;
                                }
                            } else {
                                if(current.y > start.y && direction != 2){
                                    direction = 0;
                                } else if(current.y < start.y && direction != 0){
                                    direction = 2;
                                }
                            }
                        }
                        start.x = current.x; start.y = current.y;
                    }
                }
            } else {
                x = evt.pageX;
                y = evt.pageY;
            }
        }
    }
    
    function inputEnd(){
        start.x = -1;
        current.x = -1;
        
    }
    
    scaleCanvas();
    makeStartVurm();
	animate();
        
    /*
    Put some noise in there. 
    BG Effects on collisions, cuts, and eating
    */
	</script>
</body>
</html>