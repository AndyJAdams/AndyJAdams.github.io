<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Twenty1</title>
	<style type="text/css">
		body{ 
			margin: 0; 
		}
		canvas{
			border: 1px solid black;
            touch-action: none;
		}
	</style>
</head>
<body>
	<canvas id='canvas'></canvas>
	
	<script>
	//Locate the canvas element
	var canvas = document.getElementById('canvas');
	//Scale to full screen
	function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	}
	scaleCanvas();
	//Get the 2D Drawing context for our 2D game
	var ctx = canvas.getContext('2d');

	//Display debug data on blocks
	var DebugDisplay = true;

	//Grid valey width via block insets
	var inset = 10;

	/*
	var colorArray = [
	'#3cb44b','#42d4f4','#e6194b','#911eb4','#ffe119',
	'#9a6324','#469990','#bfef45','#800000','#ffd8b1',
	'#4363d8','#f032e6','#fabebe','#aaffc3','#f58231',
	'#808000','#748BA7','#e6beff','#fffac8','#a9a9a9'
	];
	*/
	var colorArray = [
	'#050505','#080808','#0B0B0B','#0D0D0D','#0F0F0F',
	'#252525','#282828','#2b2b2b','#2d2d2d','#2f2f2f',
	'#454545','#484848','#4b4b4b','#4d4d4d','#4f4f4f',
	'#656565','#686868','#6b6b6b','#6d6d6d','#6f6f6f',
	];

	//Object for position data storage
	function Position(x,y,r,c){
		this.x = x;
		this.y = y;
		this.r = r;
		this.c = c;
	}

	//Block Object
	function Block(x,y,w,h,value,r,c){
		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
		this.r = r;
		this.c = c;
		this.value = value;

		this.draw = function(){
			ctx.fillStyle = colorArray[this.value];
			ctx.fillRect(this.x+(inset/2), this.y+(inset/2), this.w-inset, this.h-inset);
			
		}

		this.update = function(){
			//Called every frame... 
			//TODO: Add animation data for movement of blocks. 
			this.draw();
		}

		this.label = function(){
			ctx.font = 'bold 36px Tahoma';
            if(this.w > 5){
			 ctx.fillStyle = '#FFF';
			 ctx.fillText(this.value +'', this.x+(this.w/2)-12, this.y+(this.w/2)+5);
			 	if(DebugDisplay){
			 		//Row & Column [BOTTOM RIGHT]
            		ctx.font ='28px Arial';
            		ctx.fillStyle = '#FFF';
            		ctx.fillText(this.r + "," + this.c,this.x+(this.w)-50,this.y+(this.w)-15);
            		//Raw position [TOP LEFT]
            		ctx.font = '26px Arial';
            		ctx.fillStyle = '#BBB';
            		ctx.fillText(Math.round(this.x) + "," + Math.round(this.y),this.x+8,this.y+30);
            	}
            }
            
		}
	}	

	//Extend Array to support multidimensions via .matrix function
	//We pass rows and then columns
	Array.matrix = function(rows,columns){
		var col = [];
		for(var i = 0; i < columns; i++){
			var row = [];
			for(var j = 0; j < rows; j++){
				row[j] = undefined;
			}
			col[i] = row;
		}
		//An array of columns contains a block from each row within it. 
		return col;
	}

	var gridRows = 5; //number of rows
	var gridCols = 4; // number of columns

	var blockScale = ((innerWidth*0.85)/gridCols); //Since this is mobile centric... we base our scale of overall width or number of columns
	var blockArray = Array.matrix(gridRows,gridCols); //Make the array
	var positions = Array.matrix(gridRows,gridCols); //Make an array of positions ... not sure if this is needed

	var gridHeight = (blockScale * gridRows); //Height of grid used for centering
	var gridWidth = (blockScale * gridCols); //Width of grid used for centering

	//Let's make some blocks!
	for(var x = 0; x < gridCols; x++){ //Iterate through columns
		for(var y = 0; y < gridRows; y++){ //iterate through rows

			var xpos = (x*blockScale)+(innerWidth/2-gridWidth/2); //this is the xposition but x is actually the column
			var ypos = (y*blockScale)+(innerHeight/2-gridHeight/2); //this is the yposition but y is the rows since rows stack upward (e.g. Y AXIS)
			blockArray[x][y] = new Block(xpos, ypos,blockScale,blockScale,Math.round(Math.random()*7)+1,x,y); //Make the block
			positions[x][y] = new Position(xpos,ypos,x,y); // Stash the position
		}
	}

	//Game loop [ ~ 60FPS ]
	function animate(){

		//Recursive call (Basically the game's do-while playing loop)
		window.requestAnimationFrame(animate);
		//Clear the whole screen every frame
		ctx.clearRect(0,0,innerWidth,innerHeight);
        
        //Update and label the blocks every frame
		for(var i = 0; i < blockArray.length; i++){
			for(var j = 0; j < blockArray[i].length; j++){
	            if(blockArray[i][j] != undefined){
	                blockArray[i][j].update();
	                blockArray[i][j].label();
	            }
	        }
		}
	}

	var mx = 0; //Touch || Mouse initial input position on x
    var my = 0; //Touch || Mouse initial input position on y

    //Find the block closest to the page mapped position
	var closestBlock = undefined;    
	function findClosestBlock(a,b){
		for(var i = 0; i < blockArray.length;i++){
			for(var j = 0; j < blockArray[i].length; j++){
				if(
	                blockArray[i][j] != undefined && 
	                a > blockArray[i][j].x && 
	                a < blockArray[i][j].x+blockArray[i][j].w && 
	                b > blockArray[i][j].y && 
	                b < blockArray[i][j].y+blockArray[i][j].h
	            ){
					return blockArray[i][j];
				}
			}
		}
        return undefined;
	}

	window.addEventListener('touchstart', function(evt){
        evt.preventDefault();
		mx = evt.changedTouches[0].pageX;
        my = evt.changedTouches[0].pageY; 
    }, false);
	
    window.addEventListener('touchmove', function(evt){
        evt.preventDefault();
    }, false);
	
    window.addEventListener('touchcancel', function(evt){
        evt.preventDefault();
        closestBlock = undefined;
    }, false);
	
	//User has removed finger... let's figure out the desired action here. 
    window.addEventListener('touchend', function(evt){
        evt.preventDefault();
        //Where did the finger / pointer disengage?
        var emx = evt.changedTouches[0].pageX;
        var emy = evt.changedTouches[0].pageY;

        //What is the closest block to the starting touch?
        closestBlock = findClosestBlock(mx,my);

        if(closestBlock != undefined){
        	var cval = closestBlock.value; 
            if(Math.abs(emx-mx) > Math.abs(emy-my)){
                //Horizontal
                if(Math.abs(emx-mx) > blockScale/2){
                    if(emx-mx > 0){ //The finger actually moved in some direction... this will later be tweaked as drag sensitivity
                        //Right
                        var rblock = findClosestBlock(mx+blockScale,emy); //Closest block in the direction of the end position. 
                        if(rblock != undefined){
                            var rval = rblock.value;
                            if(rval+cval < 22){
                            	if(validMove(rblock,closestBlock)){ //Insure cardinal direction movements only 
	                                rblock.value = rval+cval; //Assign sum to end block
	                                closestBlock.w = inset; //Devalue/Remove the dragged block
	                                Remove21(); //Call to remove blocks of 21 and then drop to fill gaps.
	                            }
                            }
                        }
                    } else if(emx-mx < 0){
                        //Left
                        var lblock = findClosestBlock(mx-blockScale,emy);
                        if(lblock != undefined){
                        	var lval = lblock.value;
                        	if(lval+cval < 22){
                        		if(validMove(lblock,closestBlock)){
	                        		lblock.value = lval + cval;
	                        		closestBlock.w = inset;
	                        		Remove21();
	                        	}
                        	} 
                        }
                    }
                }
            } else {
                if(Math.abs(emy-my) > blockScale/2){
                    if(emy-my > 0){
                        //Down
                        var dblock = findClosestBlock(emx,blockScale+my);
                        if(dblock != undefined){
                        	var dval = dblock.value;
                        	if(dval+cval < 22){
                        		if(validMove(dblock,closestBlock)){
	                        		dblock.value = dval + cval;
	                        		closestBlock.w = inset;;
	                        		Remove21();
	                        	}
                        	}
                        }
                    } else if(emy-my < 0){
                        //Up
                        var ublock = findClosestBlock(emx,my-blockScale);
                        if(ublock != undefined){
                        	var uval = ublock.value;
                        	if(uval+cval < 22){
                        		if(validMove(ublock,closestBlock)){
	                        		ublock.value = uval+cval;
	                        		closestBlock.w = inset;
	                        		Remove21();
	                        	}
                        	}
                        }
                    }
                }
            }
            
        }
        closestBlock = undefined; //reset touch parameters
    }, false);

    function validMove(a,b){
    	if(a.r == b.r || a.c == b.c){ //Actions only available in 4 cardinal directions
    		return true;
    	}
    	return false;
    }

    function Remove21(){
    	for(var i = 0; i < blockArray.length; i++){
    		for(var j = 0; j < blockArray[i].length; j++){
	    		if(blockArray[i][j].value == 21){
	    			console.log("TODO ADD SCORE HERE");
	    			blockArray[i][j].w = inset;
	    		}
	    	}
    	}
    	DropBlocks();
    }

    function DropBlocks(){
    	/*
    	for(var i = blockArray.length-1; i > -1; i--){
    		if(blockArray[i].w < 1){
    			//Get the blocks above this and move down
    			var replacement = -1;
    			for(var x = 0; x < blockArray.length; x++){
    				console.log(x + "=" + blockArray[x].c);
    				if(blockArray[x].c == blockArray[i].c && blockArray[x].r < blockArray[i].r && blockArray[x].w > 1 && replacement == -1){
    					//We have found a block to replace  the missing one. 
    					replacement = x;
    				}
    			}

    			if(replacement == -1){
    				//No replacement found just make up a new number...?
    			} else {
    				Debug = "Replacing " + blockArray[i].y + " with " + blockArray[replacement].y;
    				var bny = blockArray[replacement].y;
    				var bnr = blockArray[replacement].r;
    				blockArray[replacement].y = blockArray[i].y;
    				blockArray[replacement].r = blockArray[i].r;
    				blockArray[i].y = bny;
    				blockArray[i].r = bnr;
    				//No we have swapped them... create a new tile for the missing one!
    			}
    		}
    	}
    	*/
    	for(var i = 0; i < blockArray.length; i++){
    		for(var j = blockArray[i].length-1; j > -1; j--){
    			if(blockArray[i][j].w < inset+2){
    				console.log(blockArray[i][j].c + "," + blockArray[i][j].r);
    				var u = -1;
    				for(var x = j-1; x > -1; x--){
    					if(blockArray[i][x].w > inset && u == -1){
    						u = x;
    					}
    				}
    				if(u == -1){
    					//NO REPLACEMENT
    				} else {
    					var uy = blockArray[i][u].y;
    					var uc = blockArray[i][u].c;
    					blockArray[i][u].y = blockArray[i][j].y;
    					blockArray[i][u].c = blockArray[i][j].c;
    					blockArray[i][j].y = uy;
    					blockArray[i][j].c = uc;

    				}
    				// console.log('Gap at ' + i + "," + j);
    				// if(j-1 > -1){
    					
    				// }
    			}
    		}
    	}
    }

	animate();
	</script>
</body>
</html>