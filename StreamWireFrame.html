<!DOCTYPE HTML>
<html>
<head>
	<meta lang="en/us"/>
	<meta encoding="UTF-8">
	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
	<title>TEST_BED</title>
	<style>
		body{
			margin: 0;
			touch-action: none;
			position: fixed;
		}

		canvas{
			touch-action: none;
			background-color: #000;
		}
	</style>
</head>
<body>
<canvas id='canvas'></canvas>
<script>

var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
var center = {x:innerWidth/2,y:innerHeight/2};

function Point(x,y){
	this.x = x; this.y = y;
}

function Vector(x1,y1,x2,y2){
	this.x = x2-x1;
	this.y = y2-y1;
	this.mag = Math.sqrt(this.x*this.x+this.y*this.y);
	this.xn = this.x/this.mag;
	this.yn = this.y/this.mag;
}

function Segment(x,y,distToOrg,radius,thickness){
	this.x = x; this.y = y; this.d = distToOrg; this.r = radius; this.t = thickness;
	this.draw = function(){
		var a = pointOnRadius(this.r,90,this.x,this.y);
		var b = pointOnRadius(this.r,210,this.x,this.y);
		var c = pointOnRadius(this.r,330,this.x,this.y);
		ctx.beginPath();
		ctx.moveTo(a.x, a.y);
		ctx.lineTo(b.x,b.y);
		ctx.lineTo(c.x,c.y);
		ctx.closePath();
		ctx.stroke();
	}
}


//Need to draw an equilateral triangle
var radius = 80;
var angle = 0;
var gap =0;
var thickness = 0;
var v = 0; 
var shift1 = 0;
var shift2 = 0;
var shift3 = 0;
var step = 7;
var targetAngle = 60;
var timeStep = Date.now()+6000;
var hop = 10;
var rate = 1;
var interval = 0;
function animate(){
	
	if(step == 0){
		if(shift1 < hop){
			shift1+= rate;
		} else {
			step = 1;
		}
	} else if(step == 1){
		if(shift1 >= rate){
			shift1-= rate;
		} else {
			step = 2;
		}
	} else if(step == 2){
		if(shift2 < hop){
			shift2+= rate;
		} else {
			step = 3;
		}
	} else if(step == 3){
		if(shift2 >= rate){
			shift2 -= rate;
		} else {
			step = 4;
		}
	} else if(step ==4){
		if(shift3 < hop){
			shift3+= rate;
		} else {
			step = 5;
		}
	} else if(step ==5){
		if(shift3 >= rate){
			shift3 -= rate;
		} else {
			step = 6;
		}
	} else if(step == 6){
		if(angle < targetAngle){
			angle+=5;
		} else {
			targetAngle+= 60;
			if(angle == 360){
				targetAngle = 60;
				angle = 0;
				timeStep = Date.now()+6000;
				interval++;
				if(interval == 3){
					step = 8;
				} else {
					step = 7;	
				}
			}else {
				step =  0;
			}
		}
	} else if(step==7){
		if(thickness < 18){
			thickness++;
		} else {
			if(Date.now() > timeStep){
				step = 0;
			}
		}
	} else if(step==8){
		interval = 0;
		if(thickness > 0){
			thickness--;
		} else {
			if(Date.now() > timeStep){
				timeStep = Date.now()+8000;
				step = 7;
			}
		}
	}
	window.requestAnimationFrame(animate);
	ctx.clearRect(0,0,innerWidth,innerHeight);

	//ctx.fillText(angle+ " " + radius + " " + gap + " " + thickness,20,20);

	var origin = new Point(innerWidth/2,innerHeight/2);
	var a = pointOnRadius(radius,angle+90,origin.x, origin.y);
	var b = pointOnRadius(radius,angle+210,origin.x, origin.y);
	var c = pointOnRadius(radius,angle+330,origin.x, origin.y);

	var v1 = new Vector(origin.x, origin.y,a.x, a.y);
	var v2 = new Vector(origin.x, origin.y,b.x, b.y);
	var v3 = new Vector(origin.x, origin.y,c.x, c.y);
	
	var hyp = Math.pow(radius,2);
	var a2 = Math.pow((getDistance(a.x, a.y, b.x, b.y)/2),2);
	var innerRad = Math.sqrt(hyp-a2);
	var d = pointOnRadius(innerRad,angle+30,origin.x,origin.y);
	var e = pointOnRadius(innerRad,angle+150,origin.x,origin.y);
	var f = pointOnRadius(innerRad,angle+270,origin.x,origin.y);
	
	ctx.fillStyle='#FFF';
	// ctx.fillRect(origin.x-2,origin.y-2,4,4);

	// ctx.fillStyle='#888';
	// ctx.fillRect(d.x-1,d.y-1,2,2);
	// ctx.fillRect(e.x-1,e.y-1,2,2);
	// ctx.fillRect(f.x-1,f.y-1,2,2);

	// ctx.fillStyle='#0F0';
	// ctx.fillRect(a.x-1,a.y-1,2,2);
	// ctx.fillRect(b.x-1,b.y-1,2,2);
	// ctx.fillRect(c.x-1,c.y-1,2,2);

	// ctx.fillStyle='#F00';
	var g = pointBetween(d.x,d.y,a.x,a.y,gap);
	var h = pointBetween(d.x,d.y,a.x,a.y,gap+thickness);
	// ctx.fillRect(g.x-1,g.y-1,2,2);
	// ctx.fillRect(h.x-1,h.y-1,2,2);

	var i = pointBetween(d.x,d.y,c.x,c.y,gap);
	var j = pointBetween(d.x,d.y,c.x,c.y,gap+thickness);
	// ctx.fillRect(i.x-1,i.y-1,2,2);
	// ctx.fillRect(j.x-1,j.y-1,2,2);

	var k = pointBetween(e.x,e.y,a.x,a.y,gap);
	var l = pointBetween(e.x,e.y,a.x,a.y,gap+thickness);
	// ctx.fillRect(k.x-1,k.y-1,2,2);
	// ctx.fillRect(l.x-1,l.y-1,2,2);

	var m = pointBetween(e.x,e.y,b.x,b.y,gap);
	var n = pointBetween(e.x,e.y,b.x,b.y,gap+thickness);
	// ctx.fillRect(m.x-1,m.y-1,2,2);
	// ctx.fillRect(n.x-1,n.y-1,2,2);

	var o = pointBetween(f.x,f.y,c.x,c.y,gap);
	var p = pointBetween(f.x,f.y,c.x,c.y,gap+thickness);
	// ctx.fillRect(o.x-1,o.y-1,2,2);
	// ctx.fillRect(p.x-1,p.y-1,2,2);

	var q = pointBetween(f.x,f.y,b.x,b.y,gap);
	var r = pointBetween(f.x,f.y,b.x,b.y,gap+thickness);
	// ctx.fillRect(q.x-1,q.y-1,2,2);
	// ctx.fillRect(r.x-1,r.y-1,2,2);

	ctx.beginPath();
	ctx.moveTo(g.x+v1.xn*shift1,g.y+v1.yn*shift1);
	ctx.lineTo(h.x+v1.xn*shift1,h.y+v1.yn*shift1);
	ctx.lineTo(l.x+v1.xn*shift1,l.y+v1.yn*shift1);
	ctx.lineTo(k.x+v1.xn*shift1,k.y+v1.yn*shift1);
	ctx.lineTo(g.x+v1.xn*shift1,g.y+v1.yn*shift1);

	ctx.moveTo(i.x+v3.xn*shift3,i.y+v3.yn*shift3);
	ctx.lineTo(j.x+v3.xn*shift3,j.y+v3.yn*shift3);
	ctx.lineTo(p.x+v3.xn*shift3,p.y+v3.yn*shift3);
	ctx.lineTo(o.x+v3.xn*shift3,o.y+v3.yn*shift3);
	ctx.lineTo(i.x+v3.xn*shift3,i.y+v3.yn*shift3);

	ctx.moveTo(m.x+v2.xn*shift2,m.y+v2.yn*shift2);
	ctx.lineTo(n.x+v2.xn*shift2,n.y+v2.yn*shift2);
	ctx.lineTo(r.x+v2.xn*shift2,r.y+v2.yn*shift2);
	ctx.lineTo(q.x+v2.xn*shift2,q.y+v2.yn*shift2);
	ctx.lineTo(m.x+v2.xn*shift2,m.y+v2.yn*shift2);
	ctx.fill();

	// ctx.beginPath();
	// ctx.moveTo(d.x,d.y);
	// ctx.lineTo(e.x,e.y);
	// ctx.lineTo(f.x,f.y);
	// ctx.closePath();
	// ctx.fill();

	
	

}


function pointOnRadius(rad,angle,orgX,orgY){
	var x = rad*Math.cos(degToRad(angle));
	var y = rad*Math.sin(degToRad(angle));
	return new Point(x+orgX,y+orgY);
}

function pointBetween(x1,y1,x2,y2,dist){
	var dbp = Math.sqrt(Math.pow((x2-x1),2)+Math.pow((y2-y1),2));
	var ratio = dist/dbp;
	var x = x1+ratio*(x2-x1);
	var y = y1+ratio*(y2-y1);
	return new Point(x,y);
}

function degToRad(deg){
	return deg*(Math.PI/180);
}

function getDistance(x1,y1,x2,y2){
	return Math.abs(Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2)));
}

window.addEventListener('keydown',function(evt){
	//console.log(evt.key);
	switch(evt.key){
		case 'ArrowUp':
			angle++;
			//gap++;
			break;
		case 'ArrowDown':
			angle--;
			//gap--;
			break;
		case 'k':
			gap--;
			break;
		case 'i':
			gap++;
			break;
		case 'e':
			thickness++;
			break;
		case 'f':
			thickness--;
			break;
		case 'q':
			v++;
			break;
		case 'a':
			v--;
			break;
		case '1':
			shift1++;
			break;
		case '2':
			shift1--;
			break;
		case '3':
			shift2++;
			break;
		case '4':
			shift2--;
			break;
		case '5':
			shift3++;
			break;
		case '6':
			shift3--;
			break;
		default:
			break;
	}
});

window.addEventListener('mousedown', inputStart,false);
window.addEventListener('mousemove', inputMove, false);
window.addEventListener('mouseup', inputEnd, false);

var start = {x:-1,y:-1};
var current = {x:-1,y:-1};
function inputStart(e){
	e.preventDefault();
	start.x = e.pageX; start.y = e.pageY;
	current.x = start.x; current.y = start.y;
}

function inputMove(e){
	e.preventDefault();
	if(start.x > -1){
		current.x = e.pageX; current.y = e.pageY;
	}
}

function inputEnd(){
	start.x = -1;
}

animate();
</script>
</body>
</html>