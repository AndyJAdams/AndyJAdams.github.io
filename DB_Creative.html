<!DOCTYPE HTML>
<html>
<head>
	<meta lang="en/us"/>
	<meta encoding="UTF-8">
	<title>DB_Creative</title>
	<style>
		body{
			margin: 0;
			background-color: #D6D6D6;
			touch-action: none;
			position: fixed;
		}
		canvas{
			background-color: #D6D6D6;
		}
	</style>
</head>
<body>
<canvas id='canvas'></canvas>
<script type='text/javascript'>
	var canvas = document.getElementById('canvas');
	var ctx = canvas.getContext('2d');
	
	//GLOBAL VARIABLES
	var DEBUG = false;
	var creativemode=true;
	var spacingX = 0,spacingY = 0;
	var portrait = false;
	var columns =0;
	var rows = 0;
	var selectedMode = 0;

	function scaleCanvas(){
		rows = 15;
		columns = 25;
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight-4;
		if(innerWidth < innerHeight){
			portrait = true;
			var r = rows;
			rows = columns;
			columns = r;
		}
		spacingY = (innerHeight-100)/(rows+1);
		spacingX = innerWidth/(columns);
		ctx.fillStyle='#A3A3A3';
		ctx.strokeStyle='#A3A3A3';
		buildGrid();
		buildInterface();
	}

	//Menu display section
	function Button(type,x,y,w,h){
		this.type = type; this.x = x; this.y = y;
		this.w = w; this.h = h;
		this.selected = false;

		this.draw = function(){
			ctx.fillStyle='#A3A3A3';
			if(this.selected){
				ctx.fillStyle = '#2D2D2D';
			}
			ctx.fillRect(this.x, this.y, this.w, this.h);
			switch(this.type){
				case 0: //Clear all
					ctx.strokeStyle='#D6D6D6';
					ctx.lineWidth=2;
					ctx.beginPath();
					ctx.moveTo(this.x+35,this.y+15);
					ctx.lineTo(this.x+65,this.y+45);
					ctx.moveTo(this.x+65,this.y+15);
					ctx.lineTo(this.x+35,this.y+45);
					ctx.stroke();
					ctx.closePath();
					ctx.strokeStyle='#A3A3A3';
					break;
				case 1: //Start
					ctx.fillStyle='#D6D6D6';
					ctx.beginPath();
					ctx.moveTo(this.x+35,this.y+30);
					ctx.lineTo(this.x+50,this.y+15);
					ctx.lineTo(this.x+65,this.y+30);
					ctx.lineTo(this.x+50,this.y+45);
					ctx.closePath();
					ctx.fill();
					ctx.fillStyle='#A3A3A3';
					break;
				case 2: //Solid
					ctx.strokeStyle='#D6D6D6';
					ctx.lineWidth=2;
					ctx.beginPath();
					ctx.moveTo(this.x+20,this.y+30);
					ctx.lineTo(this.x+80,this.y+30);
					ctx.stroke();
					ctx.closePath();
					ctx.strokeStyle='#A3A3A3';
					break;
				case 3: //Dashed
					ctx.strokeStyle='#D6D6D6';
					ctx.lineWidth=2;
					ctx.beginPath();
					ctx.moveTo(this.x+20,this.y+30);
					ctx.lineTo(this.x+30,this.y+30);
					ctx.moveTo(this.x+35,this.y+30);
					ctx.lineTo(this.x+45,this.y+30);
					ctx.moveTo(this.x+50,this.y+30);
					ctx.lineTo(this.x+60,this.y+30);
					ctx.moveTo(this.x+65,this.y+30);
					ctx.lineTo(this.x+75,this.y+30);
					ctx.stroke();
					ctx.closePath();
					ctx.strokeStyle='#A3A3A3';
					break;
				case 4: //Wrap
					ctx.strokeStyle='#D6D6D6';
					ctx.lineWidth=2;
					ctx.beginPath();
					ctx.moveTo(this.x,this.y+30);
					ctx.lineTo(this.x+25,this.y+30);
					ctx.moveTo(this.x+75,this.y+30);
					ctx.lineTo(this.x+100,this.y+30);
					ctx.stroke();
					ctx.closePath();
					ctx.strokeStyle='#A3A3A3';
					break;
				case 5: //END
					ctx.strokeStyle='#D6D6D6';
					ctx.lineWidth=2;
					ctx.beginPath();
					ctx.moveTo(this.x+35,this.y+30);
					ctx.lineTo(this.x+50,this.y+15);
					ctx.lineTo(this.x+65,this.y+30);
					ctx.lineTo(this.x+50,this.y+45);
					ctx.lineTo(this.x+35,this.y+30);
					ctx.stroke();
					ctx.closePath();
					ctx.strokeStyle='#A3A3A3';
					break;
				case 6: //Output
					ctx.strokeStyle='#D6D6D6';
					ctx.lineWidth=4;
					ctx.beginPath();
					//Draw a play button
					ctx.moveTo(this.x+40,this.y+15);
					ctx.lineTo(this.x+70,this.y+30);
					ctx.lineTo(this.x+40,this.y+45);
					ctx.closePath();
					//ctx.stroke();
					ctx.fillStyle='#D6D6D6';
					ctx.fill();
					ctx.strokeStyle='#A3A3A3';
					break;
				case 7:
					ctx.strokeStyle='#D6D6D6';
					ctx.lineWidth=2;
					ctx.beginPath();
					ctx.moveTo(this.x+25,this.y+15);
					ctx.lineTo(this.x+75,this.y+15);
					ctx.lineTo(this.x+50,this.y+30);
					ctx.lineTo(this.x+25,this.y+15);
					ctx.lineTo(this.x+25,this.y+45);
					ctx.lineTo(this.x+75,this.y+45);
					ctx.lineTo(this.x+75,this.y+15);
					ctx.stroke();
					ctx.closePath();
					ctx.strokeStyle='#A3A3A3';
					break;
				default:
					break;
			}
			ctx.strokeStyle='#A3A3A3';
			ctx.fillStyle='#A3A3A3';
		}
	}

	function GridPosition(x,y){
		this.x = x; this.y = y;
		this.linkV = undefined;
		this.linkH = undefined;
		this.alpha = false;
		this.omega = false;
	}

	function Link(pos,type){
		this.pos = pos;
		this.type = type;
	}

	var gridPos = [];
	function buildGrid(){
		gridPos = [];
		for(var y = 0; y < rows; y++){
			for(var x =0; x < columns; x++){
				var posX = (x*spacingX)+(spacingX/2);
				var posY = (y*spacingY)+(spacingY/2);
				gridPos.push(new GridPosition(posX, posY));
			}
		}
	}

	var btnArray = [];
	function buildInterface(){
		btnArray = [];
		for(var b = 0;b<8;b++){
			btnArray.push(new Button(b,(innerWidth/2-425)+(b*110),innerHeight-100,100,60));
		}
		btnArray[1].selected = true;
	}

	function animate(){
		window.requestAnimationFrame(animate);
		ctx.clearRect(0,0,innerWidth,innerHeight);

		for(var i =0; i < gridPos.length; i++){
			if(creativemode){
				ctx.fillStyle = '#B3B3B3';
				ctx.fillRect(gridPos[i].x-2,gridPos[i].y-2,4,4);
			}
			if(gridPos[i].alpha){
				ctx.beginPath();
				ctx.moveTo(gridPos[i].x-10,gridPos[i].y);
				ctx.lineTo(gridPos[i].x,gridPos[i].y-10);
				ctx.lineTo(gridPos[i].x+10,gridPos[i].y);
				ctx.lineTo(gridPos[i].x,gridPos[i].y+10);
				ctx.closePath();
				ctx.fill();
			} 
			if(gridPos[i].omega){
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.moveTo(gridPos[i].x-10,gridPos[i].y);
				ctx.lineTo(gridPos[i].x,gridPos[i].y-10);
				ctx.lineTo(gridPos[i].x+10,gridPos[i].y);
				ctx.lineTo(gridPos[i].x,gridPos[i].y+10);
				ctx.closePath();
				ctx.stroke();
			}

			if(gridPos[i].linkV != undefined){
				drawLinkConnection(gridPos[i],gridPos[i].linkV);
			}
			if(gridPos[i].linkH != undefined){
				drawLinkConnection(gridPos[i],gridPos[i].linkH);
			}

		}

		if(creativemode){
			var nearest = getNearestSnapPosition(mx,my);
			if(nearest != undefined){
				ctx.fillRect(nearest.x-4,nearest.y-4,8,8);
			}

			if(initialPos != undefined){
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.moveTo(initialPos.x-6,initialPos.y-6);
				ctx.lineTo(initialPos.x+6,initialPos.y-6);
				ctx.lineTo(initialPos.x+6,initialPos.y+6);
				ctx.lineTo(initialPos.x-6,initialPos.y+6);
				ctx.lineTo(initialPos.x-6,initialPos.y-6);
				ctx.stroke();
				ctx.closePath();
			}
		}

		if(DEBUG){
			ctx.textAlign = 'start';
			ctx.fillText(rows+"x"+columns,5,innerHeight-10);
			ctx.fillText("@"+mx+","+my,5,innerHeight-30);
		}

		if(creativemode){
			for(var b = 0; b < btnArray.length-1;b++){
				btnArray[b].draw();
			}
		} else {
			btnArray[6].draw();
			btnArray[7].draw();
		}
	}

	function drawLinkConnection(pos,link){
		var m = link.type;
		ctx.lineWidth = 2;
		ctx.strokeStyle = '#A3A3A3';
		switch(m){
			case 2: //Solid
				ctx.setLineDash([]);
				ctx.beginPath();
				ctx.moveTo(pos.x,pos.y);
				ctx.lineTo(link.pos.x,link.pos.y);
				ctx.stroke();
				ctx.closePath();
				break;
			case 3: //Dashed
				ctx.setLineDash([3,6]);
				ctx.beginPath();
				ctx.moveTo(pos.x,pos.y);
				ctx.lineTo(link.pos.x,link.pos.y);
				ctx.stroke();
				ctx.closePath();
				ctx.setLineDash([]);
				break;
			case 4: //Wrap
				ctx.setLineDash([]);
				if(Math.abs(pos.x-link.pos.x)>spacingX*2){ //Horizontal
					if(pos.x < link.pos.x){ //LEFT
						ctx.beginPath();
						ctx.moveTo(pos.x,pos.y);
						ctx.lineTo(-20,pos.y);
						ctx.moveTo(link.pos.x,link.pos.y);
						ctx.lineTo(innerWidth+20,link.pos.y);
						ctx.stroke();
						ctx.closePath();
					} else { //RIGHT
						ctx.beginPath();
						ctx.moveTo(pos.x,pos.y);
						ctx.lineTo(innerWidth+20,pos.y);
						ctx.moveTo(link.pos.x,link.pos.y);
						ctx.lineTo(-20,link.pos.y);
						ctx.stroke();
						ctx.closePath();
					}
				} else if(Math.abs(pos.y-link.pos.y)>spacingY*2){//Vertical
					if(pos.y < link.pos.y){//UP
						ctx.beginPath();
						ctx.moveTo(pos.x,pos.y);
						ctx.lineTo(pos.x,-20);
						ctx.moveTo(link.pos.x,link.pos.y);
						ctx.lineTo(link.pos.x,innerHeight+20);
						ctx.stroke();
						ctx.closePath();
					} else {//DOWN
						ctx.beginPath();
						ctx.moveTo(pos.x,pos.y);
						ctx.lineTo(pos.x,innerHeight+20);
						ctx.moveTo(link.pos.x,link.pos.y);
						ctx.lineTo(link.pos.x,-20);
						ctx.stroke();
						ctx.closePath();
					}
				}
				break;
			default:
				break;
		}
	}

	function getNearestSnapPosition(x,y){
		var dist = innerWidth;
		var retPos = undefined;
		for(var i = 0; i < gridPos.length;i++){
			if(gridPos[i] != undefined){
				var d = Math.sqrt(Math.pow(Math.abs(gridPos[i].x-x),2)+Math.pow(Math.abs(gridPos[i].y-y),2));
				if(d < spacingX && d < spacingY && d < dist){
					retPos = gridPos[i];
					dist = d;
				}
			}
		}
		return retPos;
	}

	function getMapData(){
		var d = rows+'.'+columns+',';
		for(var a = 0; a < gridPos.length; a++){ //Collect all starts
			if(gridPos[a].alpha){
				d += a+'.';
			}
		}
		d += ',';
		for(var b = 0; b < gridPos.length; b++){ //Collect all positions w/ links
			if(gridPos[b].linkV != undefined){
				var linkIndex = getGridIndex(gridPos[b].linkV.pos);
				if(linkIndex > -1){
					d+=b+'-'+linkIndex+'-'+gridPos[b].linkV.type+'.';
				}
			}
			if(gridPos[b].linkH != undefined){
				var linkIndex = getGridIndex(gridPos[b].linkH.pos);
				if(linkIndex > -1){
					d+=b+'-'+linkIndex+'-'+gridPos[b].linkH.type+'.';
				}
			}
		}
		d += ',';
		for(var c = 0; c < gridPos.length; c++){
			if(gridPos[c].omega){
				d += c+'.';
			}
		}
		return d;
	}

	function getGridIndex(pos){
		for(var i =0; i < gridPos.length;i++){
			if(pos == gridPos[i]){
				return i;
			}
		}
		return -1;
	}

	function clearMap(){
		for(var i =0; i < gridPos.length;i++){
			gridPos[i].alpha = false;
			gridPos[i].omega = false;
			gridPos[i].linkV = undefined;
			gridPos[i].linkH = undefined;
			selectedMode = 1;
		}
	}

	//------INPUT CONTROLS ---------------------------------------
	//Input variables
	var mx, my;
	var initialPos = undefined;


	window.addEventListener('resize', function(){
		scaleCanvas();
	});

	//Mouse
	window.addEventListener('mousedown', function(evt){
    	evt.preventDefault();
    },false);
    window.addEventListener('mousemove', function(evt){
    	evt.preventDefault();
    	mx = evt.pageX;
    	my = evt.pageY;
    },false);
    window.addEventListener('mouseup', function(evt){
    	evt.preventDefault();
    	if(my > innerHeight-100){
    		dectectMenuInput();
    	} else {
    		detectGridInput();
    	}
    },false);

    //Keyboard
	window.addEventListener('keydown',function(evt){
	});
	window.addEventListener('keyup',function(evt){
		if(evt.keyCode==68){
			DEBUG = !DEBUG;
		}
	});

	//Touch
	window.addEventListener('touchstart', function(evt){
        evt.preventDefault();
		mx = evt.changedTouches[0].pageX;
        my = evt.changedTouches[0].pageY;
    }, false);
	
    window.addEventListener('touchmove', function(evt){
        evt.preventDefault();
        mx = evt.changedTouches[0].pageX;
        my = evt.changedTouches[0].pageY; 
    }, false);
	
    window.addEventListener('touchcancel', function(evt){
        evt.preventDefault();
    }, false);
	
	//User has removed finger... let's figure out the desired action here. 
    window.addEventListener('touchend', function(evt){
        evt.preventDefault();
        if(my > innerHeight-100){
        	dectectMenuInput();
        } else {
        	detectGridInput();
        }
    }, false);

 	function makeMenuSelection(i){
 		for(var b = 0; b < btnArray.length; b++){
 			if(b == i){
 				btnArray[b].selected = true;
 			} else {
 				btnArray[b].selected = false;
 			}
 		}
 		selectedMode = i;
 	}

    function dectectMenuInput(){
    	if(my > innerHeight-100 && my < innerHeight-40){
	        if(mx > innerWidth/2-325 && mx < innerWidth/2-225){
	        	makeMenuSelection(1);
	        } else if(mx > innerWidth/2-215 && mx < innerWidth/2-115){
	        	makeMenuSelection(2);
	        } else if(mx > innerWidth/2-105 && mx < innerWidth/2-5){
	        	makeMenuSelection(3);
	        } else if(mx > innerWidth/2+5 && mx < innerWidth/2+105){
	        	makeMenuSelection(4);
	        } else if(mx > innerWidth/2+115 && mx < innerWidth/2+215){
	        	makeMenuSelection(5);
	        } else if(mx > innerWidth/2+225 && mx < innerWidth/2+325){
	        	makeMenuSelection(6);
	        	creativemode = !creativemode;
	        } else if(mx > innerWidth/2+325 && mx < innerWidth/2+425){
	        	makeMenuSelection(6);
	        	var data = getMapData();
	       		window.open('mailto:aa?subject=diamond_box&body='+data);
	        } else if(mx > innerWidth/2-425 && mx < innerWidth/2-325){
	        	clearMap();
	        	makeMenuSelection(1);
	        }
	    }
    }

    var initialPos = undefined;
    function detectGridInput(){
    	var near = getNearestSnapPosition(mx,my);
    	if(near == undefined){
    		return undefined;
    	}
    	switch(selectedMode){
    		case 1:
				near.alpha = !near.alpha;
				initialPos = undefined;
    			break;
    		case 2:
    			if(initialPos==undefined){
    				initialPos = near;
    			} else {
    				if(initialPos.x != near.x && initialPos.y != near.y){
    					initialPos = undefined;
    					console.log("Points not in line");
    					return;
    				}
    				if(Math.abs(initialPos.x-near.x)>spacingX+5 || Math.abs(initialPos.y-near.y)>spacingY+3){
    					console.log("Points are not adjacent");
    					initialPos = undefined;
    					return;
    				}
    				if(initialPos.x < near.x){
    					setLink(initialPos,near,0,selectedMode);
    				} else if(initialPos.x > near.x){
						setLink(near,initialPos,0,selectedMode);
    				} else if(initialPos.y < near.y){
    					setLink(initialPos,near,1,selectedMode);
    				} else if(initialPos.y > near.y){
						setLink(near,initialPos,1,selectedMode);
    				}
    				initialPos = near;
    			}
    			break;
    		case 3: //Dashed
    			if(initialPos==undefined){
    				initialPos = near;
    			} else {
    				if(initialPos.x != near.x && initialPos.y != near.y){
    					initialPos = undefined;
    					console.log("Points not in line");
    					return;
    				}
    				if(Math.abs(initialPos.x-near.x)>spacingX+5 && Math.abs(initialPos.y-near.y)>spacingY+3){
    					initialPos = undefined;
    					console.log("Points are not adjacent");
    					return;
    				}
    				if(initialPos.x < near.x){
    					setLink(initialPos,near,0,selectedMode);
    				} else if(initialPos > near.x){
    					setLink(near,initialPos,0,selectedMode);
    				} else if(initialPos.y < near.y){
    					setLink(initialPos,near,1,selectedMode);
    				} else if(initialPos.y > near.y){
    					setLink(near,initialPos,1,selectedMode);
    				}
    				initialPos = near;
    			}
    			break;
    		case 4:
    			if(initialPos==undefined){
    				initialPos = near;
    			} else {
    				if(initialPos.x != near.x && initialPos.y != near.y){
    					console.log("Points not in line");
    					initialPos = undefined;
    					return;
    				}
    				if(initialPos.x > near.x){
    					setLink(initialPos,near,0,selectedMode);
    				} else if(initialPos.x < near.x){
    					setLink(near,initialPos,0,selectedMode);
    				} else if(initialPos.y > near.y){
    					setLink(initialPos,near,1,selectedMode);
    				} else if(initialPos.x < near.y){
    					setLink(near,initialPos,1,selectedMode);
    				}
    				initialPos = near;
    			}
    			break;
    		case 5:
    			near.omega = !near.omega;
    			initialPos = undefined;
    			break;
    		default:
    			break;
    	}
    }

    function setLink(pos1,pos2,dir,mode){
    	if(dir = 0){//Horizontal
    		var nLink = new Link(pos2,mode);
			if(pos1.linkH != undefined){
				if(pos1.linkH.type != mode){
					pos1.linkH = nLink;		
				} else {
					pos1.linkH = undefined;
				}
			} else {
				pos1.linkH =nLink;		
			}
    					
    	} else {//Vertical
    		var nLink = new Link(pos2,mode);
			if(pos1.linkV != undefined){
				if(pos1.linkV.type != mode){
					pos1.linkV = nLink;		
				} else {
					pos1.linkV = undefined;
				}
			} else {
				pos1.linkV =nLink;		
			}
    	}
    }

	scaleCanvas();
	animate();
</script>
</body>
</html>