<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>4OUT</title>
	<style type="text/css">
		body{
            margin: 0;
            touch-action: none;
            position: fixed;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
        }
        canvas{
            touch-action: none;
        }
	</style>
</head>
<body id='body'>
	<canvas id='canvas'></canvas>
	<script>
    //Global Variables Here
    var DEBUG = true;
    var version = 0.0001;
    var grid = {x:4,y:6};
    var tileScale = {x:0,y:0};
    
    var tiles = [];
        
	var canvas = document.getElementById('canvas');	
    function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
        tileScale.x = innerWidth/grid.x;
        tileScale.y = innerHeight/grid.y;
        scaleGrid();
	}
	var ctx = canvas.getContext('2d');

    var colorArray = ["#F8B195","#F67280","#C06C84","#6C5B7B","#355C7D","#2A363B","#A8A7A7"];
        
	function Tile(x,y,w,h,gx,gy,t){
        this.x = x; this.y = y;
        this.w = w; this.h = h;
        this.gx = gx; this.gy = gy; this.t = t;
        this.draw=function(){
            ctx.fillStyle=colorArray[this.t];
            ctx.fillRect(this.x,this.y,this.w+1,this.h+1);
            
            if(DEBUG){
                ctx.fillStyle='#FFF';
                ctx.font = '14px sans-serif';
                ctx.fillText(this.gx+","+this.gy + " " + this.t,this.x+5,this.y+16);
            }
        }
        
        this.update = function(){
            this.draw();
        }
    }
        
    function buildGrid(){
        for(let i=0; i < grid.x; i++){
            var column = [];
            for(let j = 0; j < grid.y; j++){
                column.push(new Tile(i*tileScale.x,j*tileScale.y,tileScale.x,tileScale.y,i,j,Math.floor(Math.random()*colorArray.length)));
            }
            tiles.push(column);
        }
    }
    
    function scaleGrid(){
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j<tiles[i].length; j++){
                var t = tiles[i][j];
                t.x = t.gx*tileScale.x;
                t.y = t.gy*tileScale.y;
                t.w = tileScale.x;
                t.h = tileScale.y;
            }
        }
    }

	function animate(){
		window.requestAnimationFrame(animate);
        if(start.x > -1 || tiles.length > 1){
            ctx.clearRect(0,0,innerWidth,innerHeight);
            for(var i = 0; i < tiles.length; i++){
                for(var j = 0; j < tiles[i].length; j++){
                    tiles[i][j].update();
                }
            }
        } else {
            buildGrid();
        }
	}
        
    //*** GAMEPLAY HELPERS ***//
    function getNeighbors(t){
        var n = [];
        if(t.gx-1 > 0){ //LEFT
            n.push(tiles[t.gx-1][t.gy]);
        }
        if(t.gx+1 < grid.x){//RIGHT
            n.push(tiles[t.gx+1][t.gy]);
        }
        if(t.gy-1 > 0){//UP
            n.push(tiles[t.gx][t.gy-1]);
        }
        if(t.gy+1 < grid.y){
            n.push(tiles[t.gx][t.gy+1]);
        }
        return n;
    }

	//*** INPUT SECTION **//
    var start = {x:-1,y:-1};
    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        scaleCanvas();
    });
    
    
    window.addEventListener('mousedown',inputStart,false);
    window.addEventListener('mousemove',inputMove,false);
    window.addEventListener('mouseup',inputEnd,false);

    window.addEventListener('touchstart',inputStart, false);
    window.addEventListener('touchmove', inputMove,false);
    window.addEventListener('touchcancel',inputEnd,false);
    window.addEventListener('touchend',inputEnd,false);
    
    function inputStart(evt){
        evt.preventDefault();
        if(evt.changedTouches != undefined){
            var touches = evt.changedTouches;
            if(touches.length > 0){
                start.x = touches[0].pageX;
                start.y = touches[0].pageY;
            }
        } else {
            start.x = evt.pageX;
            start.y = evt.pageY;
        }
    }
    
    function inputMove(evt){
        evt.preventDefault();
        var x = -1; var y = -1;
        if(start.x > -1){
            if(evt.changedTouches != undefined){
                var touches = evt.changedTouches;
                if(touches.length > 0){
                    x = touches[0].pageX;
                    y = touches[0].pageY;
                }
            } else {
                x = evt.pageX;
                y = evt.pageY;
            }
        }
    }
    
    function inputEnd(){
        start.x = -1;
    }
    
    scaleCanvas();
	animate();
        
    /*TODO LIST
    1. Collect tiles of touching similar type
    2. Detect tile selection
    3. Move tile(s) accordingly
        3.a Single tiles can wrap, larger groups cannot
        3.b Tiles should slide together as one unit, and follow the input pointer on the selected axis of movement
        3.c larger groups will need to move the entire collection accross all rows or columns. **THIS WILL BE PARTICULARLY TRICKY**
    4. Detect tile collections of 4 or more
    5. Remove tile collections of 4 or more
    6. Drop tiles appropriately, but do NOT break apart larger groups... this leaves space for empty areas. 
    7. Empty areas will also terminate a cycling
    8. 
    */
	</script>
</body>
</html>