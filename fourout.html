<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>4OUT</title>
	<style type="text/css">
		body{
            margin: 0;
            touch-action: none;
            position: fixed;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
        }
        canvas{
            touch-action: none;
        }
	</style>
</head>
<body id='body'>
	<canvas id='canvas'></canvas>
	<script>
    //Global Variables Here
    var DEBUG = true;
    var version = 0.0001;
    var grid = {x:4,y:6};
    var tileScale = {x:0,y:0};
    
    var tiles = [];
    var selected = [];
    var arow = []; var acol = [];


	var canvas = document.getElementById('canvas');	
    function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
        tileScale.x = innerWidth/grid.x;
        tileScale.y = innerHeight/grid.y;
        scaleGrid();
	}
	var ctx = canvas.getContext('2d');

    var colorArray = ["#F8B195","#F67280","#C06C84","#6C5B7B","#355C7D","#2A363B","#A8A7A7"];
        
	function Tile(x,y,w,h,gx,gy,t){
        this.x = x; this.y = y;
        this.w = w; this.h = h;
        this.gx = gx; this.gy = gy; this.t = t;
        this.owner = undefined;
        this.draw=function(){
            ctx.fillStyle=colorArray[this.t];
            ctx.fillRect(this.x,this.y,this.w+1,this.h+1);
            
            if(DEBUG){
                ctx.fillStyle='#FFF';
                ctx.font = '14px sans-serif';
                ctx.fillText(this.gx+","+this.gy + " " + this.t,this.x+5,this.y+16);
                
                if(this.owner != undefined){
                    ctx.strokeStyle='#FFF';
                    ctx.beginPath();
                    ctx.moveTo(this.x+this.w/2,this.y+this.h/2);
                    ctx.lineTo(this.owner.x+this.w/2,this.owner.y+this.h/2);
                    ctx.stroke();
                    ctx.closePath();
                }
            }
        }
        
        this.update = function(){
            getConnected(this);
            this.draw();
        }
    }
        
    function buildGrid(){
        for(let i=0; i < grid.x; i++){
            var column = [];
            for(let j = 0; j < grid.y; j++){
                column.push(new Tile(i*tileScale.x,j*tileScale.y,tileScale.x,tileScale.y,i,j,Math.floor(Math.random()*colorArray.length)));
            }
            tiles.push(column);
        }
    }
    
    function scaleGrid(){
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j<tiles[i].length; j++){
                var t = tiles[i][j];
                t.x = t.gx*tileScale.x;
                t.y = t.gy*tileScale.y;
                t.w = tileScale.x;
                t.h = tileScale.y;
            }
        }
    }
        
    function getConnected(a){
        var n = getNeighbors(a);
        var r = []; r.push(a);
        if(n.length > 0){
            for(var i = 0; i < n.length; i++){
                if(n[i].t == a.t){
                    if(n[i].owner == undefined){
                        var d = getConnected(n[i]);
                        for(var j = 0; j<d.length;j++){
                            r.push(d[j]);
                            d[j].owner = a;
                        }
                    } else {
                        a.owner = n[i].owner;
                        return r;
                    }
                }
            }
        } 
        return r;
    }

	function animate(){
		window.requestAnimationFrame(animate);
        ctx.clearRect(0,0,innerWidth,innerHeight);
        if(start.x > -1 || tiles.length > 1){
            for(var i = 0; i < tiles.length; i++){
                for(var j = 0; j < tiles[i].length; j++){
                    tiles[i][j].update();
                }
            }
            
            if(selected.length > 0){
                for(var i= 0; i < selected.length;i++){
               ctx.fillStyle='#FFF'; ctx.fillRect(selected[i].x+tileScale.x-30,selected[i].y+5,10,10);
                }

                if(arow.length > 0 && acol.length > 0){
                    for(var i = 0; i < tiles.length; i++){
                        for(var j = 0; j < tiles[i].length; j++){
                            if(contains(arow,i) || contains(acol,j)){
                                ctx.fillStyle='#000';
                                ctx.fillRect(tiles[i][j].x+tileScale.x-15,tiles[i][j].y+5,10,10);
                            }
                        }
                    }
                }
            }
        } else {
            buildGrid();
        }
	}
        
    //*** GAMEPLAY HELPERS ***//
    function getNeighbors(t){
        var n = [];
        if(t.gx+1 < grid.x){//RIGHT
            n.push(tiles[t.gx+1][t.gy]);
        }
        if(t.gy+1 < grid.y){ //DOWN
            n.push(tiles[t.gx][t.gy+1]);
        }
        return n;
    }
        
    function getSelected(x,y){
        for(var i = 0; i < tiles.length;i++){
            for(var j = 0; j < tiles[i].length;j++){
                 var t = tiles[i][j];
                if(x > t.x && x < t.x+t.w && y > t.y && y < t.y+t.h){
                    return getOwned(t);
                }
            }
        }
        console.log(x+"-"+y);
        return [];
    }
        
    function getOwned(a){
        if(a.owner != undefined){
            a = a.owner;
        }
        var o = []; o.push(a);
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                if(tiles[i][j].owner == a){
                   o.push(tiles[i][j]); 
                }
            }
        }
        return o;
    }

    function getAffected(){
        arow = []; acol = [];
        for(var i = 0; i < selected.length; i++){
            if(!contains(arow,selected[i].gx)){
                arow.push(selected[i].gx);
            }
            if(!contains(acol,selected[i].gy)){
                acol.push(selected[i].gy);
            }

        }

    }

	//*** INPUT SECTION **//
    var start = {x:-1,y:-1};
    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        scaleCanvas();
    });
    window.addEventListener('mousedown',inputStart,false);
    window.addEventListener('mousemove',inputMove,false);
    window.addEventListener('mouseup',inputEnd,false);

    window.addEventListener('touchstart',inputStart, false);
    window.addEventListener('touchmove', inputMove,false);
    window.addEventListener('touchcancel',inputEnd,false);
    window.addEventListener('touchend',inputEnd,false);
    
    function inputStart(evt){
        evt.preventDefault();
        if(evt.changedTouches != undefined){
            var touches = evt.changedTouches;
            if(touches.length > 0){
                start.x = touches[0].pageX;
                start.y = touches[0].pageY;
            }
        } else {
            start.x = evt.pageX;
            start.y = evt.pageY;
        }
        selected = getSelected(start.x,start.y);
        getAffected();
    }
    
    function inputMove(evt){
        evt.preventDefault();
        var x = -1; var y = -1;
        if(start.x > -1){
            if(evt.changedTouches != undefined){
                var touches = evt.changedTouches;
                if(touches.length > 0){
                    x = touches[0].pageX;
                    y = touches[0].pageY;
                }
            } else {
                x = evt.pageX;
                y = evt.pageY;
            }
        }
    }
    
    function inputEnd(){
        start.x = -1;
        selected = [];
    }

    /*** GENERAL FUNCTIONS ***/
    function contains(arr,obj){
        for(var i = 0; i < arr.length; i++){
            if(arr[i] == obj){
                return true;
            }
        }
        return false;
    }

    scaleCanvas();
	animate();
        
    /*TODO LIST
    1. Get affected column and row after selection
    2. Detect movement direction
    3. Move tile(s) accordingly
        3.a Single tiles can wrap, larger groups cannot
        3.b Tiles should slide together as one unit, and follow the input pointer on the selected axis of movement
        3.c larger groups will need to move the entire collection accross all rows or columns. **THIS WILL BE PARTICULARLY TRICKY**
    4. Detect tile collections of 4 or more
    5. Remove tile collections of 4 or more
    6. Drop tiles appropriately, but do NOT break apart larger groups??
    */
	</script>
</body>
</html>