<!DOCTYPE HTML>
<html>
<head>
	<meta lang="en/us"/>
	<meta encoding="UTF-8">
	<title>4-OUT</title>
	<style>
		body{
			margin: 0;
		}
	</style>
</head>
<body>
<canvas id='canvas'></canvas>
<script type='text/javascript'>
	var canvas = document.getElementById('canvas');
	var ctx = canvas.getContext('2d');
	//Global Variables
	var DEBUG = true;
	var drag = false;
	var colorArray = ['#f19066','#574b90','#f5cd79','#f78fb3','#546de5','#303952','#3dc1d3','#c44569'];
	var speedDampner = 1;
	var rows = 10;
	var columns = 7;
	var tileScale = 0;
	var affectedRow = [];
	var affectedColumn = [];
	var closestTile = undefined;
	var mouseDownX = -1, mouseDownY = -1;
	var currentMouseX = -1, currentMouseY = -1;
	var horzvert = undefined;
	scaleCanvas();

	//OBJECT DEFINITIONS

	function Tile(x,y,r,value,row,column){
		this.x = x;
		this.y = y;
		this.r = r/2;
		this.value = value;
		this.tx = this.x;
		this.ty = this.y;
		this.row = row;
		this.column = column;
		this.spacing = 10;
		this.targetSpacing = this.spacing;

		this.draw = function(){
			ctx.fillStyle= this.value;
			//ctx.fillRect(this.x,this.y,this.r,this.r);
			ctx.beginPath();
			ctx.arc(this.x+this.r, this.y+this.r,this.r-this.spacing,0,2*Math.PI);
			ctx.fill();
			ctx.closePath();

			if(DEBUG){
				ctx.fillStyle='#000';
				ctx.font = "20px helvetica";
				ctx.fillText(this.row+","+this.column,this.x,this.y);
			}
		}

		this.update = function(){
			if(this.spacing > this.targetSpacing){
				this.spacing-= Math.abs(this.spacing-this.targetSpacing)/2;
			} else if(this.spacing < this.targetSpacing){
				this.spacing+= Math.abs(this.spacing-this.targetSpacing)/2;
			}
			if(this.x < this.tx){
				this.x += Math.abs((this.tx-this.x)/speedDampner);
			} else if(this.x > this.tx){
				this.x -= Math.abs((this.x-this.tx)/speedDampner);
			}

			if(this.y < this.ty){
				this.y += Math.abs((this.ty-this.y)/speedDampner);
			} else if(this.y > this.ty){
				this.y -= Math.abs((this.y-this.ty)/speedDampner);
			}

			this.draw();
		}
	}

	//Object containers
	var tiles = [];
	for(var r = 0; r < rows; r++){
		var col = [];
		for(var c = 0; c < columns; c++){
			var randValue = Math.floor(Math.random()*colorArray.length);
			var xOffset = (innerWidth-(columns*tileScale))/2;
			var yOffset = (innerHeight-(rows*tileScale))/2;
			col.push(new Tile(c*tileScale+xOffset,r*tileScale+yOffset,tileScale,colorArray[randValue],r,c));
		}
		tiles.push(col);
	}

	//Animate and render
	function animate(){
		window.requestAnimationFrame(animate);
		ctx.clearRect(0,0,innerWidth,innerHeight);

		if(drag){
			//Determine the drag direction from the starting mousedown position
			//The drag direction needs to exceed a minimum distance before we can start moving... 
			var horzDist = Math.abs(currentMouseX-mouseDownX);
			var vertDist = Math.abs(currentMouseY-mouseDownY);
			if(getDistance(currentMouseX,currentMouseY,mouseDownX,mouseDownY) > tileScale/2 && horzvert == undefined){
				//Now we need to determine direction
				if(horzDist > vertDist && affectedRow.length > 0){
					horzvert = 'horz';
				} else if(vertDist > horzDist && affectedColumn.length > 0){
					horzvert = 'vert';
				}
			}
			if(horzvert != undefined){
				if(horzvert == 'horz'){
					//HORIZONTAL MOVEMENT-
					resetAffectedColumn();
					if(horzDist > tileScale){
						if(currentMouseX < mouseDownX){ //LEFT
							cycle(-1,affectedRow);
						} else if(currentMouseX > mouseDownX){ //RIGHT
							cycle(1,affectedRow);
						}
					}
					resetAffectedRow();
				} else if(horzvert == 'vert'){
					//VERTICAL MOVEMENT- 
					resetAffectedRow();
					if(vertDist > tileScale){
						if(currentMouseY < mouseDownY){ //UP
							cycle(-1,affectedColumn);
						} else if(currentMouseY > mouseDownY){//DOWN
							cycle(1,affectedColumn);
						}
					}
					resetAffectedColumn();
				}
			}
		}

		//Alter affected row
		for(var i = 0; i < affectedRow.length;i++){
			affectedRow[i].targetSpacing = 30;
		}

		//Alter affected column
		for(var i = 0; i < affectedColumn.length;i++){
			affectedColumn[i].targetSpacing = 30;
		}
		if(closestTile != undefined){
			closestTile.targetSpacing = 30;
		}

		//Update tiles
		for(var a = 0; a < rows; a++){
			for(var b = 0; b < columns; b++){
					tiles[a][b].update();
			}
		}

	}

	function cycleRow(amt,group){
		//Carousel row here
	}

	function cycleColumn(amt,group){
		//Carousel column here
	}

	function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight-4;
		tileScale = (innerWidth*0.9)/columns;
		if(innerWidth>innerHeight){
			var temp = columns;
			columns = rows;
			rows = temp;
			tileScale = (innerHeight*0.8)/rows;
		}
	}	

	function getClosestTile(x,y){
		var close = undefined;
		for(var a = 0; a < rows; a++){
			if(close == undefined){
				for(var b = 0; b < columns; b++){
					if(tiles[a][b].x < x 
						&& tiles[a][b].x+tileScale > x
						&& tiles[a][b].y < y
						&& tiles[a][b].y+tileScale > y){
						if(getDistance(x,y,tiles[a][b].x+(tileScale/2),tiles[a][b].y+(tileScale/2))<tileScale/2){
							close = tiles[a][b];
						}
						break;
					}
				}
			}
		}
		return close;
	}

	function highlightRow(selected){
		for(var a = 0; a < rows; a++){
			for(var b = 0; b < columns; b++){
				if(Math.abs(tiles[a][b].y-selected.y)<tileScale/2){
					affectedRow.push(tiles[a][b]);
				}
			} 
		}
	}

	function highlightColumn(selected){
		for(var a = 0; a < rows; a++){
			for(var b = 0; b < columns; b++){
				if(Math.abs(tiles[a][b].x-selected.x)<tileScale/2){
					affectedColumn.push(tiles[a][b]);
				}
			}
		}
	}

	function getDistance(x1,y1,x2,y2){
		return Math.sqrt(Math.pow(Math.abs(x1-x2),2)+Math.pow(Math.abs(y1-y2),2));
	}

	function resetAffectedRow(){
		for(var i = 0; i < affectedRow.length; i++){
			if(affectedRow[i] != closestTile){
				affectedRow[i].targetSpacing = 10;
			}
		}
		affectedRow = [];
	}

	function resetAffectedColumn(){
		for(var i = 0; i < affectedColumn.length; i++){
			if(affectedColumn[i]  != closestTile){
				affectedColumn[i].targetSpacing = 10;
			}
		}
		affectedColumn = [];
	}

	//Input
	var closestOffsetX = -1, closestOffsetY = -1;
	var resetX = -1, resetY = -1;
	window.addEventListener('mousedown',function(evt){MOUSEDOWNEVENT(evt);});
	window.addEventListener('mousemove',function(evt){MOUSEMOVEEVENT(evt);});
	window.addEventListener('mouseup',function(evt){MOUSEUPEVENT(evt);});
		

	function MOUSEDOWNEVENT(evt){
		closestTile = getClosestTile(evt.pageX,evt.pageY);
		if(closestTile != undefined){
			//Let's highlight the row and column for the selected tile
			resetX = closestTile.x;
			resetY = closestTile.y;
			highlightRow(closestTile);
			highlightColumn(closestTile);
			mouseDownX = evt.pageX;
			mouseDownY = evt.pageY;
			drag = true;
		}
	}

	
	function MOUSEUPEVENT(evt){
		//TODO: Set the new positions of the altered tiles. 
		resetAffectedRow();
		resetAffectedColumn();
		if(closestTile != undefined){
			resetX = -1;
			resetY = -1;
			closestTile.targetSpacing = 10;
			closestTile = undefined;
		}
		drag = false;
		horzvert= undefined;
	}

	
	function MOUSEMOVEEVENT(evt){
		currentMouseX = evt.pageX;
		currentMouseY = evt.pageY;
	};
	animate();
</script>
</body>
</html>