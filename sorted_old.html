<DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>SORTED</title>
	<style type="text/css">
		body{
            margin: 0;
            touch-action: none;
            position: fixed;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
        }
        canvas{
            touch-action: none;
            background-color: #222;
        }
	</style>
</head>
<body id='body'>
	<canvas id='canvas'></canvas>
	<script>
    var grid = {rows: Math.floor(Math.random()*5)+2,columns: Math.floor(Math.random()*4)+3};
    var dragSensitivity = 50;
    var palettes = [
    ['#97352D','#DDD9A8','#9BC1BC','#F5F9F0','#36C9C6'],
    ['#4E3D42','#6D6466','#9F9F92','#C9D5B5','#E3DBDB'],
    ['#F9FDF7','#8997B2','#465F5D','#ADC2BF','#392A30'],
    ['#202820','#389397','#C9F6FC','#4C4295','#D0A9B2'],
    ['#000000','#FFFFFC','#BEB7A4','#FF9125','#FF3F00'],
    ['#A5341C','#29335C','#F3A712','#86A16B','#C9F5F8'],
    ['#560510','#9D454A','#F5DBCB','#97967D','#A0D4A1']
    ];
    var DEBUG = false;

	var canvas = document.getElementById('canvas');
    var randPalette = Math.floor(Math.random()*palettes.length);
		var cPalette = palettes[randPalette];
    var tileSize = {x:-1,y:-1};
    var tiles = [];
    var points = [];
		var gridScale = {x:0,y:0};
		var spacing = 15;
		var center = {x:0,y:0};
		var halfGrid = {x:0,y:0};
    //DEBUG ONLY
    // grid.rows = Math.floor(Math.random()*5)+5;
    // grid.columns = Math.floor(Math.random()*5)+5;
    // if(window.innerHeight < window.innerWidth){
    //     grid.columns = grid.rows+1;
    // } else {
    //     grid.rows = grid.columns+1;
    // }
    //

    function scaleCanvas(){
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

        tileSize = Math.floor(innerWidth/(grid.columns*2));
				center.x = innerWidth/2;
				center.y = innerHeight/2;
        //tileSize.y = innerHeight/grid.rows;
				gridScale.x = tileSize*grid.columns+(spacing*(grid.columns));
				gridScale.y = tileSize*grid.rows+(spacing*(grid.rows));
				halfGrid.x = gridScale.x/2;
				halfGrid.y = gridScale.y/2;
        if(tiles.length < 1){
            buildGrid();
        }
        scaleGrid();
				dragSensitivity = tileSize/4;
	}

	var ctx = canvas.getContext('2d');

    function Point(x,y,c,r){
        this.x = x; this.y = y; this.c = c; this.r = r;
    }

    function Tile(x,y,v,c,r){
        this.x = x; this.y = y; this.r = r; this.c = c; this.v = v;
        this.effected = false; this.dx = 0; this.dy = 0;
        this.draw = function(){
            ctx.fillStyle=cPalette[this.v];
            //ctx.fillRect(this.x+this.dx, this.y+this.dy, tileSize+1, tileSize+1);
						ctx.beginPath();
						ctx.arc(this.x+this.dx+tileSize/2,this.y+this.dy+tileSize/2,tileSize/2,0,2*Math.PI);
						ctx.fill();
						// var n = getNeighbors(this);
						// if(!allCol.includes(this) && !allRow.includes(this)){
						// 	for(var i = 0; i < n.length; i++){
						// 		if(n[i] != undefined && n[i].v == this.v){
						// 			if(!allCol.includes(n[i]) && !allRow.includes(n[i])){
						// 				ctx.lineWidth = tileSize;
						// 				ctx.strokeStyle=cPalette[this.v];
						// 				ctx.beginPath();
						// 				ctx.moveTo(this.x+this.dx+tileSize/2,this.y+this.dy+tileSize/2);
						// 				ctx.lineTo(n[i].x+n[i].dx+tileSize/2,n[i].y+n[i].dy+tileSize/2);
						// 				ctx.stroke();
						// 			}
						// 		}
						// 	}
						// }

            if(DEBUG){
                ctx.fillStyle='#000';
                ctx.fillText(this.c+","+this.r+" "+this.v,this.x+this.dx+4,this.y+this.dy+20);
                if(allCol.length > 0){
                    for(var i = 0; i < allCol.length; i++){
                        if(allCol[i] == this){
                            ctx.fillStyle='#000';
                            ctx.fillRect(this.x+tileSize/2-10+this.dx,this.y+tileSize/2-10+this.dy,20,20);
                        }
                    }
                }
                if(allRow.length > 0){
                    for(var i = 0; i < allRow.length; i++){
                        if(allRow[i] == this){
                            ctx.fillStyle='#000';
                            ctx.fillRect(this.x+tileSize/2-10+this.dx,this.y+tileSize/2-10+this.dy,20,20);
                        }
                    }
                }
            }

        }

        this.update = function(){
            ctx.fillStyle=cPalette[this.v];
            if(this.x+this.dx < center.x-halfGrid.x){
                if(this.x+this.dx+(tileSize/2) < center.x-halfGrid.x){
                    console.log("snapset left");
                    this.x += gridScale.x;
                } else {
                    //ctx.fillRect(gridScale.x+(this.x+this.dx),this.y,tileSize+1,tileSize+1);
										ctx.beginPath();
										ctx.arc(gridScale.x+(this.x+this.dx)+tileSize/2,this.y+tileSize/2,tileSize/2,0,2*Math.PI);
										ctx.fill();
                }
            } else if(this.x+this.dx+tileSize >center.x+halfGrid.x){
                if(this.x+this.dx+(tileSize/2) > center.x+halfGrid.x){
                    console.log("snapset right");
                    this.x -=gridScale.x;
                } else {
                    //ctx.fillRect((this.x+this.dx)-gridScale.x,this.y,tileSize+1,tileSize+1);
										ctx.beginPath();
										ctx.arc((this.x+this.dx)-gridScale.x+tileSize/2,this.y+tileSize/2,tileSize/2,0,2*Math.PI);
										ctx.fill();
                }
            }

            if(this.y+this.dy < center.y-halfGrid.y){
                if(this.y+this.dy+(tileSize/2) < center.y-halfGrid.y){
                    console.log("snapset up");
                    this.y += gridScale.y;
                } else {
                    //ctx.fillRect(this.x,gridScale.y+(this.y+this.dy),tileSize+1,tileSize+1);
										ctx.beginPath();
										ctx.arc(this.x+tileSize/2,gridScale.y+(this.y+this.dy)+tileSize/2,tileSize/2,0,2*Math.PI);
										ctx.fill();
                }
            } else if(this.y+this.dy+tileSize > center.y+halfGrid.y){
                if(this.y+this.dy+(tileSize/2) > center.y+halfGrid.y){
                    console.log("snapset down");
                    this.y -= gridScale.y;
                } else {
                    //ctx.fillRect(this.x,(this.y+this.dy)-gridScale.y,tileSize+1,tileSize+1);
										ctx.beginPath();
										ctx.arc(this.x+tileSize/2,(this.y+this.dy)-gridScale.y+tileSize/2,tileSize/2,0,2*Math.PI);
										ctx.fill();
                }
            }
            this.draw();

            //this.draw();
        }
    }

    function buildGrid(){
        tiles = [];
        points = [];
        for(var i = 0; i < grid.columns; i++){
            var row = [];
            var p_row = [];
            for(var j = 0; j < grid.rows; j++){
                var x = i*tileSize+(center.x-halfGrid.x)+spacing*i+spacing/2;
                var y = j*tileSize+(center.y-halfGrid.y)+spacing*j+spacing/2;
                var v = Math.floor(Math.random()*(cPalette.length-1));
                row.push(new Tile(x,y,v,i,j));
                p_row.push(new Point(x,y,i,j));
            }
            tiles.push(row);
            points.push(p_row);
        }
    }

    function scaleGrid(){
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                tiles[i][j].x = i*tileSize+(center.x-halfGrid.x)+spacing*i+spacing/2;
                tiles[i][j].y = j*tileSize+(center.y-halfGrid.y)+spacing*j+spacing/2;
                points[i][j].x = i*tileSize+(center.x-halfGrid.x)+spacing*i+spacing/2;
                points[i][j].y = j*tileSize+(center.y-halfGrid.y)+spacing*j+spacing/2;
            }
        }
    }

    var collections = [];
    function makeCollections(){
        collections = [];
				return;
        for(var i = tiles.length-1; i > -1; i--){
            for(var j = tiles[i].length-1; j > -1; j--){
                var col = -1;
                var matches = [tiles[i][j]];
                //starting from the last tile we can check the right and down tiles for matches
                //right is I
                if(i+1 < tiles.length && tiles[i+1][j] != undefined){
                    if(tiles[i+1][j].v == tiles[i][j].v){
                        //We found a match. Check all the collections for the matching tile
                        for(var c = 0; c < collections.length; c++){
                            if(collections[c].includes(tiles[i+1][j])){
                                collections[c].unshift(tiles[i][j]);
                                col = c;
                                break;
                            }
                        }
                        if(col == -1){
                            matches.push(tiles[i+1][j]);
                        }
                    }
                }
                //down is j
                if(j+1 < tiles[i].length && tiles[i][j+1] != undefined){
                    if(tiles[i][j+1].v == tiles[i][j].v){
                        for(var c = 0; c < collections.length; c++){
                            if(collections[c].includes(tiles[i][j+1])){
                                if(col == -1){ //We didn't find a collection on the right
                                    collections[c].unshift(tiles[i][j]);
                                    if(matches.length > 1){
                                        collections[c].unshift(matches[1]);
                                        matches = [];
                                    }

                                    col = c;
                                } else {
                                    //So the right found a collection... and bottom found a collection
                                    if(col == c){
                                        //It's the same collection!
                                        collections[c].unshift(tiles[i][j]);
                                    } else {
                                        //It's a different collection???!
                                        //Move all of the new collection over to the previous...
                                        //to make one giant collection
                                        for(var t = 0; t < collections[c].length; t++){
                                            if(!collections[col].includes(collections[c][t])){
                                                collections[col].unshift(collections[c][t]);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if(col == -1){ //Matches were found in 1 or more tiles, but no collections were identified
                            matches.unshift(tiles[i][j+1]);
                        }
                    }
                }
                if(matches.length > 1){
                    collections.push(matches);
                    matches = [];
                }
            }
        }

        for(var m = 0; m < collections.length; m++){
            //collections[m]=removeDups(collections[m]);
            collections[m] = [...new Set(collections[m])];
        }
    }
    var selection = undefined;
    function makeSelection(x,y){
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                var t = tiles[i][j];
                if(x < t.x+tileSize && x > t.x && y < t.y+tileSize && y > t.y){
                    selection = tiles[i][j];
                    break;
                }
            }
            if(selection != undefined){
                break;
            }
        }
				if(selection != undefined){
	        effectedCol = [selection.c];
	        getEffectedCol();
	        effectedRow = [selection.r];
	        getEffectedRow();
				}
    }

    function getEffectedCol(){
        var change = false;
        for(var i = 0; i < effectedCol.length; i++){ //Loop through the effected columns
            for(var j = 0; j < tiles[effectedCol[i]].length;j++){ //Check the rows of those columns
                var t = tiles[effectedCol[i]][j]; //Short hand :)
                for(var f = 0; f < collections.length; f++){ //Loop and see if this tile is in a collection
                    if(collections[f].includes(t)){ //Uh oh we hit a collection
                        for(var d = 0; d < collections[f].length;d++){ //Loop though collection tiles
                            if(!effectedCol.includes(collections[f][d].c)){ //is there a column not already included in the effected list?
                                effectedCol.push(collections[f][d].c);
                                change = true; //Setup for repeat
                            }
                        }
                    }
                }

            }
        }
        effectedCol = [...new Set(effectedCol)]; //Remove duplicates... just in case
        if(change){
            getEffectedCol(); //Let's do it again.
        }
    }

    function getEffectedRow(){
        var change = false;
        for(var j = 0; j < effectedRow.length; j++){
            for(var i = 0; i < tiles.length; i++){
                var t = tiles[i][effectedRow[j]];
                for(var f = 0; f < collections.length; f++){
                    if(collections[f].includes(t)){
                        for(var d = 0; d < collections[f].length; d++){
                            if(!effectedRow.includes(collections[f][d].r)){
                                effectedRow.push(collections[f][d].r);
                                change = true;
                            }
                        }
                    }
                }
            }
        }
        effectedRow = [...new Set(effectedRow)];
        if(change){
            getEffectedRow();
        }
    }

    function collectCols(){
        allCol = [];
        for(var i = 0; i < effectedCol.length;i++){
            for(var j = 0; j < tiles[effectedCol[i]].length; j++){
                allCol.push(tiles[effectedCol[i]][j]);
            }
        }
    }

    function collectRows(){
        allRow = [];
        for(var j = 0; j < effectedRow.length; j++){
            for(var i = 0; i < tiles.length; i++){
                allRow.push(tiles[i][effectedRow[j]]);
            }
        }
    }

    function getClosestPoint(x,y){
        var minDist = (innerWidth*innerHeight)*2;
        var close = undefined;
        for(var i = 0; i < points.length; i++){
            for(var j = 0; j < points[i].length; j++){
                var a = Math.pow(Math.abs(x-points[i][j].x),2);
                var b = Math.pow(Math.abs(y-points[i][j].y),2);
                var c = Math.sqrt(a+b);
                if(c < minDist){
                    minDist = c;
                    close = points[i][j];
                }
            }
        }
        return close;
    }

    // function calculateShift(affected){
    //     //Loop through the affected and get their nearset points
    //     for(var i = 0; i < affected.length; i++){
    //         var close = getClosestPoint(affected[i].x+affected[i].dx,affected[i].y+affected[i].dy);
    //         if(close != undefined){
    //             affected[i].x = close.x;
    //             affected[i].y = close.y;
    //             affected[i].dx = 0;
    //             affected[i].dy = 0;
    //             tiles[close.c][close.r]=affected[i];
    //         }
    //     }
    // }

    function calculateShift(){
        var affected = [];
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                affected.push(tiles[i][j]);
            }
        }
        for(var i = 0; i < affected.length; i++){
            var close = getClosestPoint(affected[i].x+affected[i].dx,affected[i].y+affected[i].dy);
            if(close != undefined){
                affected[i].x = close.x;
                affected[i].y = close.y;
                affected[i].dx = 0;
                affected[i].dy = 0;
                if(affected[i].c != close.c){
                  //  console.log("C: " + affected[i].c + " to " + close.c);
                }
                if(affected[i].r != close.r){
                  //  console.log("R: " + affected[i].r + " to " + close.r);
                }
                affected[i].c = close.c;
                affected[i].r = close.r;
                tiles[close.c][close.r]=affected[i];

            } else {
                console.log("NO NEARBY POINT FOUND");
            }
        }
    }

    // function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
    //   if (typeof stroke === 'undefined') {
    //     stroke = true;
    //   }
    //   if (typeof radius === 'undefined') {
    //     radius = 5;
    //   }
    //   if (typeof radius === 'number') {
    //     radius = {tl: radius, tr: radius, br: radius, bl: radius};
    //   } else {
    //     var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
    //     for (var side in defaultRadius) {
    //       radius[side] = radius[side] || defaultRadius[side];
    //     }
    //   }
    //   ctx.beginPath();
    //   ctx.moveTo(x + radius.tl, y);
    //   ctx.lineTo(x + width - radius.tr, y);
    //   ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    //   ctx.lineTo(x + width, y + height - radius.br);
    //   ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
    //   ctx.lineTo(x + radius.bl, y + height);
    //   ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
    //   ctx.lineTo(x, y + radius.tl);
    //   ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    //   ctx.closePath();
    //   if (fill) {
    //     ctx.fill();
    //   }
    //   if (stroke) {
    //     ctx.stroke();
    //   }

    // }

		function getNeighbors(t){
			var n = [undefined,undefined,undefined,undefined];
			if(t.c -1 > -1){
				n[3] = tiles[t.c-1][t.r];
			}
			if(t.c+1 < grid.columns){
				n[1] = tiles[t.c+1][t.r];
			}
			if(t.r-1 > -1){
				n[0] = tiles[t.c][t.r-1];
			}
			if(t.r+1 < grid.rows){
				n[2] = tiles[t.c][t.r+1];
			}
			return n;
		}


//******************************************************************************************
//******************************************************************************************
//******************************************************************************************


    var effectedCol = [];
    var effectedRow = [];
    var allCol = [];
    var allRow = [];
    var dir = -1;
	function animate(){
		window.requestAnimationFrame(animate);
		ctx.clearRect(0,0,innerWidth,innerHeight);

		ctx.fillStyle=cPalette[cPalette.length-1];
		ctx.fillRect(0,0,innerWidth,innerHeight);

        if(dir > -1){ //Move tiles
            if(dir == 0 || dir == 2){
                //Vertical
                for(var i = 0; i < allCol.length; i++){
                    allCol[i].dy = (current.y-start.y);
                }
            } else if(dir == 1 || dir == 3){
                //Horizontal
                for(var i = 0; i < allRow.length; i++){
                    allRow[i].dx = (current.x-start.x);
                }
            }

        }

        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                tiles[i][j].update();
            }
        }

        if(selection == undefined){
            makeCollections();
        }


				ctx.lineWidth = tileSize;
				ctx.strokeStyle=cPalette[cPalette.length-1];
				ctx.beginPath();
				ctx.moveTo(center.x-halfGrid.x-(tileSize/2),center.y-halfGrid.y-(tileSize/2));
				ctx.lineTo(center.x+halfGrid.x+(tileSize/2),center.y-halfGrid.y-(tileSize/2));
				ctx.lineTo(center.x+halfGrid.x+(tileSize/2),center.y+halfGrid.y+(tileSize/2));
				ctx.lineTo(center.x-halfGrid.x-(tileSize/2),center.y+halfGrid.y+(tileSize/2));
				ctx.lineTo(center.x-halfGrid.x-(tileSize/2),center.y-halfGrid.y-(tileSize/2));
				ctx.stroke();

        if(DEBUG){
						ctx.lineWidth = 2;
            ctx.fillStyle='#000';
						ctx.font = '14px sans-serif';
          	ctx.fillText("GRID: " + grid.rows+","+grid.columns, 10, 30);
						ctx.fillText('TS: '+tileSize,10,45);
						ctx.fillText('Spacing: '+spacing,10,60);
						ctx.fillStyle='#F00';
						ctx.fillText('FPS: '+60,10,80);
						ctx.fillStyle='#FF0';
						ctx.fillText(center.x-halfGrid.x,10,tiles[0][0].y-3);
						ctx.fillText(center.y-halfGrid.y,tiles[0][0].x+3,14);
						ctx.fillStyle='#000';
						ctx.fillText(gridScale.x,tiles[0][0].x,  tiles[0][0].y+gridScale.y+spacing+14);
						ctx.fillText(gridScale.y,tiles[0][0].x+gridScale.x+spacing+3,tiles[0][0].y+14);

						ctx.strokeStyle='#FFF';
						ctx.beginPath();
						ctx.moveTo(0,center.y);
						ctx.lineTo(innerWidth,center.y);
						ctx.moveTo(center.x,0);
						ctx.lineTo(center.x,innerHeight);
						ctx.stroke();

						ctx.strokeStyle='#FF0';
						ctx.beginPath();
						ctx.moveTo(0,tiles[0][0].y);
						ctx.lineTo(tiles[0][0].x,tiles[0][0].y);
						ctx.moveTo(tiles[0][0].x,0);
						ctx.lineTo(tiles[0][0].x,tiles[0][0].y);
						ctx.stroke();

						ctx.strokeStyle='#000';
						ctx.beginPath();
						ctx.moveTo(tiles[0][0].x, tiles[0][0].y+gridScale.y+spacing);
						ctx.lineTo(tiles[0][0].x+gridScale.x, tiles[0][0].y+gridScale.y+spacing);
						ctx.moveTo(tiles[0][0].x+gridScale.x+spacing,tiles[0][0].y);
						ctx.lineTo(tiles[0][0].x+gridScale.x+spacing,tiles[0][0].y+gridScale.y);
						ctx.stroke();
        }


	}


//******************************************************************************************
//******************************************************************************************
//******************************************************************************************

	//*** INPUT SECTION **//
    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        console.log('resize');
        scaleCanvas();
    });

    window.addEventListener('keyup',function(evt){
        evt.preventDefault();
        if(evt.key == 'd'){
            DEBUG = !DEBUG;
        }
				if(evt.key == 'ArrowUp'){
					spacing++;
					scaleCanvas();
				}
				if(evt.key == 'ArrowDown'){
					spacing--;
					scaleCanvas();
				}
    });


    window.addEventListener('mousedown',inputStart,false);
    window.addEventListener('mousemove',inputMove,false);
    window.addEventListener('mouseup',inputEnd,false);

    window.addEventListener('touchstart',inputStart, false);
    window.addEventListener('touchmove', inputMove,false);
    window.addEventListener('touchcancel',inputEnd,false);
    window.addEventListener('touchend',inputEnd,false);

    var start = {x:-1,y:-1};
    var current = {x:-1,y:-1};
    function inputStart(evt){
        evt.preventDefault();
        if(evt.changedTouches != undefined){
            var touches = evt.changedTouches;
            if(touches.length > 0){
                start.x = touches[0].pageX;
                start.y = touches[0].pageY;
            }
        } else {
            start.x = evt.pageX;
            start.y = evt.pageY;
        }
        current.x = start.x; current.y = start.y;
        makeSelection(start.x, start.y);
    }

    function inputMove(evt){
        evt.preventDefault();
        if(start.x > -1){
            if(evt.changedTouches != undefined){
                var touches = evt.changedTouches;
                if(touches.length > 0){
                    current.x = touches[0].pageX;
                    current.y = touches[0].pageY;
                }
            } else {
                current.x = evt.pageX;
                current.y = evt.pageY;
            }

            //Now let's do some drag detection
            if(selection == undefined){
                return;
            }

            var xDif = Math.abs(current.x-start.x);
            var yDif = Math.abs(current.y-start.y);
            if((xDif > dragSensitivity || yDif > dragSensitivity) && dir == -1){
                //We have moved far enough to execute drag
                if(xDif > yDif){
                    if(current.x < start.x){ //left
                        dir = 3;
                    } else { //right
                        dir = 1;
                    }
                    collectRows();
                } else if(yDif > xDif){
                    if(current.y < start.y){ //up
                        dir = 0;
                    } else { //Down
                        dir = 2;
                    }
                    collectCols();
                }
            }
        }
    }

    function inputEnd(){
        // if(allCol.length > 0){
        //     calculateShift(allCol);
        // }
        // if(allRow.length > 0){
        //     calculateShift(allRow);
        // }
        calculateShift();
        start.x = -1; start.y = -1;
        current.x = -1; current.y = -1;
        selection = undefined;
        effectedCol = [];
        effectedRow = [];
        dir = -1;
        allCol = [];
        allRow = [];
    }

    scaleCanvas();
	animate();
	</script>
</body>
</html>
