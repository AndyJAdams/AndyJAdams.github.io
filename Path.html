<DOCUMENT html><html><head><title>Path</title><style>body{margin:0;}#canvas{background-color: #d2dae2;}</style></head>
<body><canvas id='canvas'></canvas><script>
var can = document.querySelector('canvas');
function scaleCanvas(){can.width = window.innerWidth;
can.height = window.innerHeight;}
scaleCanvas();
var ctx = can.getContext('2d');
ctx.lineCap = 'round';
ctx.lineJoin = 'round';
ctx.font = '28px Verdana';
ctx.fillStyle='#ffa801';
var holdtime, starttime;
var best = 0;
function Point(x,y){
	this.x = x;
	this.y = y;
	this.tarX = this.x;
	this.prevX = this.x;

	this.update = function(){
		if(this.x < this.tarX){
			this.x += (this.tarX-this.x)/4;
		} else if(this.x > this.tarX){
			this.x -= (this.x-this.tarX)/4;
		}
	}
}

function Obstacle(x,y, radius){
	this.x = x;
	this.y = y;
	this.radius= radius;

	this.draw = function(){
		ctx.fillStyle='#2c3e50';
		ctx.beginPath();
		ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI);
		ctx.fill();
		ctx.closePath();
		var cdist = getDistance(player.x, player.y+80, this.x, this.y);
		if(cdist < player.radius+this.radius){
			//Collided w/ player
			fail = true;
		}
	}

	this.update = function(){
		//Check for collision if so pop the player off the line...
		//otherwise... drop until removal
		//if(!fail){
			this.y += 8+(this.radius/10);
		//}
		
		this.draw();

	}
}

function Player(x,y,radius){
	this.x = x;
	this.y = y;
	this.radius = radius;
	this.nearestPoint = undefined;
	this.wave = 0.0;
	this.flipped = false;
	this.arms = false;
	this.moveDelta = 0;
	this.failTimer = new Date();
	
	this.draw = function(){
		if(fail){
			this.y += this.radius;
		}
		if(this.wave > 1.0){
			this.flipped = true;
		} else if(this.wave < -1.0){
			this.flipped = false;
		}
		if(!this.flipped){
			this.wave+= 0.5;
		} else {
			this.wave -= 0.5;
		}
		if(this.nearestPoint != undefined){
			//ctx.fillRect(this.nearestPoint.x-5, this.nearestPoint.y-5,10,10);
			//ARMS
			ctx.strokeStyle='#FF6C09';
			if(Math.abs(this.nearestPoint.x-this.x) < 50 && !fail){
				ctx.beginPath();
				ctx.moveTo(this.nearestPoint.x, this.nearestPoint.y);
				ctx.lineTo(this.x-(this.radius*0.7), this.y+75);
				ctx.moveTo(this.x+(this.radius*0.5), this.y+75);
				ctx.lineTo(this.nearestPoint.x, this.nearestPoint.y);

				ctx.stroke();
				this.arms = false;
				this.failTimer = 0;
				holdtime = Math.floor((new Date()-starttime)/10)/100;
				ctx.fillStyle='#FF6C09';
				ctx.font = "48pt Helvetica";
				ctx.fillText(holdtime+"s",20,70);
			} else { //Waving
				ctx.beginPath();
				ctx.moveTo(this.x-(this.radius/2), this.y+75);
				ctx.lineTo(this.x-(this.radius+30), (this.y+75)+(Math.sin(this.wave)*15));
				ctx.moveTo(this.x+(this.radius/2), this.y+75);
				ctx.lineTo(this.x+(this.radius+30), (this.y+75)-(Math.sin(this.wave)*15));
				ctx.stroke();
				this.arms = true;
				if(this.failTimer == 0){
					this.failTimer = new Date();
				}

			}
			
			//HEAD
			ctx.beginPath();
			if(this.nearestPoint.x < this.x-20 && !this.arms){
				ctx.arc(this.x-7, this.y-this.radius+75,this.radius*0.7,0,2*Math.PI);
			} else if(this.nearestPoint.x > this.x+20 && !this.arms){
				ctx.arc(this.x+7, this.y-this.radius+75,this.radius*0.7,0,2*Math.PI);
			} else {
				ctx.arc(this.x,this.y-this.radius+75,this.radius*0.7,0,2*Math.PI);
			}
			ctx.fillStyle='#FF6C09';
			ctx.fill();
			ctx.closePath();
			
			//LEGS
			ctx.beginPath();
			ctx.moveTo((this.x+this.moveDelta)-10,this.y+110);
			ctx.lineTo(this.x-10,this.y+80);
			ctx.lineTo(this.x+10,this.y+80);
			ctx.lineTo((this.x+this.moveDelta)+10,this.y+110);
			ctx.stroke();
			ctx.closePath();

			if(this.moveDelta < 0.0){
				this.moveDelta += Math.abs(this.moveDelta)/4;
			} else if(this.moveDelta > 0.0){
				this.moveDelta -= this.moveDelta/4;
			}

			//Body
			ctx.beginPath();
			ctx.arc(this.x, this.y+80, this.radius, 0, 2 * Math.PI);
			ctx.fillStyle = '#FF6C09';
			ctx.strokeStyle = '#FF6C09';
			ctx.fill();
			ctx.stroke();
			ctx.closePath();
		}
		
		if(this.failTimer > 0 && !fail){
			//var dif = 3-Math.floor((new Date()-this.failTimer)/300);
			//ctx.font='28px Verdana';
			//ctx.fillText(dif+'', this.x, this.y + 80);
			if(new Date() - this.failTimer > 1000){
				fail = true;
			} 
		}
		
		
	}	
}

var pointCount = 30;
var dist = innerHeight/(pointCount-1);
var pointArray=[];
var interval = 0;
var limit = 60;
var steps = 0;
for(var i = 0; i < pointCount; i++){
	pointArray.push(new Point(innerWidth/2, i*dist));
}

var fail = false; var start = false;
var obstacles = [];
var player = new Player(innerWidth/2, innerHeight/2, 15);
var difficulty = innerWidth/6;
var increase = false;
player.nearestPoint = pointArray[Math.ceil(pointArray.length/2)-3];
function animate(){
	window.requestAnimationFrame(animate);
	ctx.clearRect(0,0,innerWidth,innerHeight);
	//if(clicked){
		interval++;
		ctx.lineWidth = 6;
		ctx.beginPath();
		for(var p = 0; p < pointArray.length; p++){
			if(p == 0){
				ctx.strokeStyle='#2c3e50';
				ctx.moveTo(pointArray[p].x,pointArray[p].y);
				if(!fail){
					if(interval >= limit){
						pointArray[p].tarX = ((Math.random()-0.5)*difficulty)+innerWidth/2;
						difficulty+= 10;
						if(difficulty > innerWidth/2){
							difficulty = innerWidth/2;
						}
						interval = 0;
						steps++;
						if(steps >= 30){
							limit -= 5;
							if(limit < 10){
								limit = 10;
							}
							steps = 0;
						}
					}
				} else {
					ctx.font = "48pt Helvetica";
					ctx.fillText(holdtime+"s",20,70);
				}
			} else {
				ctx.lineTo(pointArray[p].x, pointArray[p].y);
				if(!fail){
					pointArray[p].tarX = pointArray[p-1].x;
				}
			}
			pointArray[p].update();
		}
		ctx.stroke();

		player.draw();
		start = true;

		if(holdtime > 5){
			if(Math.floor(holdtime) % 10 == 0 && !increase){
				obstacles.push(new Obstacle(player.x + (Math.random()-0.5), -50, Math.random() * 30+10));
				increase = true;
			}
			if(Math.floor(holdtime) % 10 != 0){
				increase = false;
			}
			for(var o = 0; o < obstacles.length;o++){
				obstacles[o].update();
				if(obstacles[o].y > innerHeight + obstacles[o].radius+10 && !fail){
					obstacles[o] = new Obstacle(player.x + (Math.random()-0.5), -50, Math.random() * 30+10);
				}
			}

		}
		ctx.font = "12pt Helvetica";
		ctx.fillStyle='#2c3e50';
		if(best > 0){
			var time = best;
			if(holdtime > best){
				time = holdtime;
			}
			ctx.fillText('best:'+time,20,20);
		} else {
			ctx.fillText('Hold On',20,20);
		}

	// } else {
	// 	ctx.font = '18px Verdana';
	// 	if(!start){
	// 		ctx.fillText("HANG ON", 20,60);
	// 	} else {
	// 		if(!fail){
	// 			ctx.fillText("PAUSED, CLICK TO RESUME", 20, 60);
	// 		} else {
	// 			ctx.fillText('CLICK TO RETRY', 20, 60);
	// 		}
	// 	}
	// }
	
}
var prevMouseX = innerWidth/2;
var clicked = false;
window.addEventListener('mousemove', function(e){
	if(!fail){
		var x = e.pageX;
		var y = e.pageY;
		player.x = x;
		player.y = y;
		//Get the nearest point via pointArray
		var nearestPoint = undefined;
		var ny = 10000;
		for(var i = 0; i < pointArray.length; i++){
			//Get the closest point on the line
			if(Math.abs(pointArray[i].y-player.y) < ny){
				ny = Math.abs(pointArray[i].y-player.y);
				nearestPoint = pointArray[i];
			}
			//assign the nearest point only if it's outside the cirlce range. 
		}
		if(nearestPoint != undefined){
			player.nearestPoint = nearestPoint;
		}

		player.moveDelta -= x-prevMouseX;

		prevMouseX = x;
	} 
});

window.addEventListener('mousedown', function(e){
	clicked = true;
	if(fail){
		if(holdtime > best){
			updateScore(holdtime);
		}
		player = new Player(e.pageX, e.pageY, 15);
		this.failTimer = 0;
		fail = false;
		starttime = new Date();
		obstacles = [];
	}
});

window.addEventListener('mouseup', function(e){
	clicked = false;
	
});

window.addEventListener('mouseleave', function(e){
	clicked = false;
});

window.addEventListener('resize', function(e){
	scaleCanvas();
})

//TOUCH CONTROLS
canvas.addEventListener('touchmove',function(e){
	player.x = e.touches[0].x;
	player.y = e.touches[0].y + 80;
	var np = undefined;
	for(var i = 0; i < pointArray.length; i++){
		//Get the closest point on the line
		if(Math.abs(pointArray[i].y-player.y) < ny){
			ny = Math.abs(pointArray[i].y-player.y);
			nearestPoint = pointArray[i-2];
		}
		//assign the nearest point only if it's outside the cirlce range. 
	}
	if(nearestPoint != undefined){
		player.nearestPoint = nearestPoint;
	}

	player.moveDelta -= x-prevMouseX;

	prevMouseX = x;

	e.preventDefault();
});

function getDistance(x1, y1, x2, y2){
	return Math.sqrt(Math.pow(Math.abs(x1-x2),2)+Math.pow(Math.abs(y1-y2),2));
}

function updateScore(score){
	if(typeof(Storage) != undefined){
		localStorage.setItem('HoldOnGame_JS13K',''+score);
		best = localStorage.getItem('HoldOnGame_JS13K');
	}
}


starttime = new Date();
animate();
</script></body></html>