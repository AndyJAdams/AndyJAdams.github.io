<!DOCTYPE HTML>
<html>
<head>
	<meta lang="en/us"/>
	<meta encoding="UTF-8">
	<title>TEST_BED</title>
	<style>
		body{
			margin: 0;
			touch-action: none;
			position: fixed;
		}
		canvas{
			touch-action: none;
		}
	</style>
</head>
<body>
<canvas id='canvas'></canvas>
<script type='text/javascript'>
    const DEBUG = true;
    var colorArray = ['#000','#55415F','#646964','#D77355','#508CD7','#64B964','#E6C86E','#CCC'];
    var whiteList = [];

    var tiles = [];
    var positions = [];
    var grid = {col: 5,row: 9};
    var tileScale = {x:0,y:0};
    var selected = undefined;
    var start = {x:-1,y:-1};
    var offset = {x:-1,y:-1};
    var moveSpeed = {x:0,y:0};
    
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    
    function scaleCanvas(){
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        tileScale.x = innerWidth/grid.col;
        tileScale.y = innerHeight/grid.row;
        moveSpeed.x = tileScale.x/4;
        moveSpeed.y = tileScale.y/4;
    }
    
    function scaleGrid(){
         tiles.forEach(function(r){
             r.forEach(function(t){
                 t.x = t.column*tileScale.x;
                 t.y = t.row*tileScale.y;
                 t.w = tileScale.x;
                 t.h = tileScale.y;
             })
        });
    }
    
    function Position(x,y){
        this.x = x; this.y = y;
    }
    
    function Tile(x,y,w,h,row,column, value){
        this.x = x; this.y = y; this.w = w; this.h = h; this.row = row; this.column = column;
        this.dx = this.x; this.dy = this.y;
        this.value = value;
        this.lastCollected = undefined;
        this.draw = function(){
            ctx.fillStyle= colorArray[this.value];
            ctx.fillRect(this.x,this.y,this.w+1,this.h+1);
            if(DEBUG){
                ctx.fillStyle='#FFF';
                ctx.fillText(this.column+","+this.row,this.x+2,this.y+20);
                if(this.lastCollected != undefined){
                    ctx.beginPath();
                    ctx.moveTo(this.x+30,this.y+50);
                    ctx.lineTo(this.lastCollected.x+30,this.lastCollected.y+50);
                    ctx.stroke();
                    ctx.closePath();
                }
            }
        }
        
        this.update = function(){
            
            this.draw();
        }
    }
    
    function buildGrid(){
        tiles = [];
        for(var i = 0; i < grid.col; i++){
            var row = [];
            var vert = [];
            for(var k = 0; k < grid.row; k++){
                var randColor = Math.floor(Math.random()*colorArray.length);
                row.push(new Tile(i*tileScale.x,k*tileScale.y,tileScale.x,tileScale.y,k,i,randColor));
                vert.push(new Position(i*tileScale.x, k*tileScale.y));
            }
            tiles.push(row);
            positions.push(vert);
        }
    }
    
    function getColumn(c){
        var retColumn = [];
        tiles.forEach(function(r){
            r.forEach(function(t){
                if(t.column == c){
                    retColumn.push(t);
                }
            })
        });
        return retColumn;
    }
    
    function getRow(r){
        var retRow = [];
         tiles.forEach(function(a){
             a.forEach(function(t){
                 if(t.row == r){
                     retRow.push(t);
                 }
             })
        });
        return retRow;
    }
    
    function cycle(arr,dir=-1){
        if(dir < 0){ //Removes from end and adds to start
            //Update the tiles array with the new row and column coordinates
            var srow = arr[0].row; var scol = arr[0].column;
            for(let i = 0; i < arr.length-1; i++){
                tiles[arr[i+1].column][arr[i+1].row] = arr[i];
            }
            tiles[scol][srow] = arr[arr.length-1];
            updateGridAssignments();
            arr.unshift(arr.pop());
        } else if(dir > 0){ //Removes from start and adds at end
            var lrow = arr[arr.length-1].row; var lcol = arr[arr.length-1].column;
            for(let i = arr.length-1; i > 0; i--){
                tiles[arr[i-1].column][arr[i-1].row] = arr[i];
            }
            tiles[lcol][lrow] = arr[0];
            updateGridAssignments();
            arr.push(arr.shift());
        } else {
            console.log("NO CYCLE ON ZERO DIRECTION");
        }
        return arr;
    }
                  
    function updateGridAssignments(){
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                tiles[i][j].column = i;
                tiles[i][j].row = j;
            }
        }    
    }
    
    function animate(){
        window.requestAnimationFrame(animate);
        ctx.clearRect(0,0,innerWidth,innerHeight);
        
        ctx.fillStyle='#404040';
        ctx.fillRect(0,0,innerWidth,innerHeight);
        
        tiles.forEach(function(r){
             r.forEach(function(t){
                t.update();
             })
        });
    }
    
    function getSelected(x,y){
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                var t = tiles[i][j];
                if(t.x < x && t.x+t.w > x && t.y < y && t.y+t.h > y){
                    return t;
                }
            }
        }
    }
    
    function checkNeigbors(tile){
        if(tile.column+1 < grid.col){
            if(tiles[tile.column+1][tile.row].value == tile.value){
                return true;
            } 
        }
        if(tile.row+1<grid.row){
            if(tiles[tile.column][tile.row+1].value == tile.value){
                return true;
            } 
        }
        if(tile.column-1 > -1){
            if(tiles[tile.column-1][tile.row].value == tile.value){
                return true;
            }
        }
        if(tile.row-1 > -1){
            if(tiles[tile.column][tile.row-1].value == tile.value){
                return true;
            }  
        }
        //We need to make sure this isn't the only one... 
        if(valueCount(tile.value) < 2){
            return true;
        }
        console.log(tile.column + "," + tile.row + " no matches found?");
        return false;
    }
    
    function valueCount(val){
        var count = 0;
        tiles.forEach(function(a){
             a.forEach(function(t){
                 if(t.value == val){
                        count++;
                 }
             })
        });
        return count;
    }
    

    function validateGrid(){
        var blacklist = [];
        var collections = [];
        for(var i = 0; i < tiles.length; i++){
            for(var j = 0; j < tiles[i].length; j++){
                var t = tiles[i][j];
                // if(!checkNeigbors(t)){
                //     console.log("FAILBOAT");
                //     return false;
                // }

                if(!blacklist.includes(t)){
                    var res = recursiveCheck(t);
                    console.log(i+","+j+" " + res.length);
                    for(var k = 0; k < res.length; k++){
                        blacklist.push(res[k]);
                    }
                    collections.push(res);
                }
                whiteList = [];
            }

        }

        //Now we check if any of the collections have values that match other collections
        //This would mean that we have two groups of the same value
        for(var i = 0; i < collections.length; i++){
            var checkVal = collections[i][0].value;
            for(var j = 0; j < collections.length; j++){
                if(collections[j][0].value == checkVal && j != i){
                    console.log(i + " v " + j + " " + collections[i].length + "/" + collections[j].length);
                    return false;
                }
            }
        }
        console.log("WINNER!");
        buildGrid();
        return true;
    }

    function recursiveCheck(tile, calling=undefined){
        var result = []; var res = [];
        result.push(tile);
        whiteList.push(tile);
        if(tile.column+1 < grid.col){ //RIGHT
            if(tiles[tile.column+1][tile.row].value == tile.value && tiles[tile.column+1][tile.row] != calling){
                if(!whiteList.includes(tiles[tile.column+1][tile.row])){
                    tiles[tile.column+1][tile.row].lastCollected = tile;
                    res = recursiveCheck(tiles[tile.column+1][tile.row],tile);
                    for(var i = 0; i < res.length; i++){
                        result.push(res[i]);
                    }
                }
            } 
        }
        if(tile.row+1<grid.row){ //DOWN
            if(tiles[tile.column][tile.row+1].value == tile.value && tiles[tile.column][tile.row+1] != calling){
                if(!whiteList.includes(tiles[tile.column][tile.row+1])){
                    tiles[tile.column][tile.row+1].lastCollected = tile;
                    res = recursiveCheck(tiles[tile.column][tile.row+1],tile);
                    for(var i = 0; i < res.length; i++){
                        result.push(res[i]);
                    }
                }
            } 
        }
        if(tile.column-1 > -1){ //LEFT
            if(tiles[tile.column-1][tile.row].value == tile.value && tiles[tile.column-1][tile.row] != calling){
                if(!whiteList.includes(tiles[tile.column-1][tile.row])){
                    tiles[tile.column-1][tile.row].lastCollected = tile;
                    res = recursiveCheck(tiles[tile.column-1][tile.row],tile);
                    for(var i = 0; i < res.length; i++){
                        result.push(res[i]);
                    }
                }
            }
        }
        if(tile.row-1 > -1){ //UP
            if(tiles[tile.column][tile.row-1].value == tile.value && tiles[tile.column][tile.row-1] != calling){
                if(!whiteList.includes(tiles[tile.column][tile.row-1])){
                    tiles[tile.column][tile.row-1].lastCollected = tile;
                    res = recursiveCheck(tiles[tile.column][tile.row-1],tile);
                    for(var i = 0; i < res.length; i++){
                        result.push(res[i]);
                    }
                }
            }  
        }
        return result;
    }
    
    //*** INPUT SECTION **//
    
    window.addEventListener('resize',function(evt){
        evt.preventDefault();
        scaleCanvas();
        scaleGrid();
    });
    
    
    window.addEventListener('mousedown',function(evt){
        evt.preventDefault();
        inputStart(evt.pageX,evt.pageY);
    });
    
    window.addEventListener('mousemove',function(evt){
        evt.preventDefault();
        inputMove(evt.pageX,evt.pageY);
    });
    
    window.addEventListener('mouseup', function(evt){
        evt.preventDefault();
        inputEnd();
    });
    
    function inputStart(x,y){
        start.x = x;
        start.y = y;
        
        selected = getSelected(x,y);
        if(selected != undefined){
            offset.x = selected.x-x;
            offset.y = selected.y-y;
        }
    }
    
    function inputMove(x,y){
        if(start.x > -1){
            if(selected != undefined){
                if(Math.abs(x-start.x) > tileScale.x/8 || Math.abs(y-start.y) > tileScale.y/8){
                    if(Math.abs(x-start.x) > Math.abs(y-start.y)){
                        //Horizontal
                        selected.x = x+offset.x;
                        selected.y = positions[selected.column][selected.row].y;
                        var srow = getRow(selected.row);
                       
                        if(Math.abs(x-start.x) > tileScale.x*0.5){
                            if(x > start.x){
                                start.x += tileScale.x;
                                srow = cycle(srow,-1);
                                snapToPositions(selected);
                            } else {
                                start.x -= tileScale.x;
                                srow = cycle(srow,1);
                                snapToPositions(selected);
                            }
                        }
                    } else {
                        //Vertical
                        selected.y = y+offset.y;
                        selected.x = positions[selected.column][selected.row].x;
                        var scol = getColumn(selected.column);
                        
                        if(Math.abs(y-start.y) > tileScale.y*0.5){
                            if(y > start.y){
                                start.y += tileScale.y;
                                scol = cycle(scol,-1);
                                snapToPositions(selected);
                            } else {
                                start.y -= tileScale.y;
                                scol = cycle(scol,1);
                                snapToPositions(selected);
                            }
                        }
                    }
                }
                
            }
        }
    }
    
    function inputEnd(){
//        selected.x = positions[selected.column][selected.row].x;
//        selected.y = positions[selected.column][selected.row].y;
        snapToPositions();
        selected = undefined;
        start.x = -1;
        validateGrid();
    }
    
    function snapToPositions(exc=undefined){
        tiles.forEach(function(a){
             a.forEach(function(t){
                 if(t != exc){
                    t.x = positions[t.column][t.row].x;
                    t.y = positions[t.column][t.row].y;
                 }
             })
        });
    }
    
    
    scaleCanvas();
    buildGrid();
    animate();
    
</script>
</body>
</html>
About
