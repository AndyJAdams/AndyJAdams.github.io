<DOCTYPE html>
<html>
<head><title>Rolli Rover</title>
    <meta charset="UTF-8"/>
<style>
    body{margin:0;}
    canvas{background-color: #2F67A9;}
</style>
</head>
<body>
<canvas id='canvas'></canvas>
<script>


//window.screen.lockOrientation('portrait-primary');
  
    
var canvas = document.getElementById('canvas');
var half;
function scaleCanvas(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    half = innerWidth/2;
}
scaleCanvas();
var ctx = canvas.getContext('2d');

var forceX = 0;
var forceY = 0;
var applyToHoles = false;
var canControl = true;
var scoredDist = 0;
var displayScore = 0;
var gameOver = false;
var totalYforce = 0;
var bestDistance = 0;

var orient = {
    a:0,
    b:0,
    g:0
}
    
function Marble(x,y,radius,holes,bouncers){
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.orgRadius = radius;
    this.jumping = false;
    this.grounded = true;
    this.draw = function(){
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI, false);
        ctx.fillStyle='#FFF';
        ctx.fill();
        ctx.closePath();
        
    }

    this.jump = function(){
        console.log("Jumping");
    }
    
    this.update = function(holes,bouncers, blocks){
        //Check for collisions against holes
        for(var h = 0; h < holes.length;h++){
            var dist = getDistance(this.x,holes[h].x,this.y,holes[h].y);
            if(dist < holes[h].radius-this.radius){
                //we have fallen in a hole.
                forceX = 0; forceY = 0;
                //Now we shrink
                if(this.radius>0.1){
                    this.radius--;    
                } else {
                    gameOver = true;
                }
                canControl = false;
            }
        }

        //Check for collisions against blocks
        for(var k = 0; k < blocks.length; k++){
            var coll = RectCircleColliding(this,blocks[k]);
            if(coll == 1){ //Vertical
                forceY = -forceY;
            } else if(coll == 2){ //Horizontal
                forceX = -forceX;
            } else if(coll == 3){
                forceX = -forceX;
                forceY = -forceY;
            }
        }

        //Check for bounce
        for(var b = 0; b < bouncers.length;b++){
            var dist = getDistance(this.x,bouncers[b].x,this.y,bouncers[b].y);
            if(dist < bouncers[b].radius+this.radius){
                //Bounce back
                forceX = -forceX;
                forceY = -forceY;
            }
        }
        
        this.x += forceX;
        
        if(this.x-this.radius < 0){
            this.x = this.radius;
            forceX = -forceX;
            //forceX = 0;
        } else if(this.x+this.radius>innerWidth){
            this.x = innerWidth-this.radius;
            forceX = -(forceX);
            //forceX = 0;
        }
        
        if(this.y + this.radius > innerHeight){
            this.y = innerHeight-this.radius;
            forceY = -(forceY);
            //forceY = 0;
        } else if(this.y-this.radius>innerHeight/2){
            this.y += forceY;
            applyToHoles = false;
        } else {
            //Get unstuck from middle
            if(forceY > 0.0){
                this.y += forceY;
                applyToHoles = false;
            } else {
                applyToHoles = true;
                //scoredDist += forceY/100;
                totalYforce += Math.abs(forceY);
            }
        }

        this.draw();
    }
}
    
function Feature(x,y,radius, type,color){
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.type = type;
    this.color = color;
    
    this.draw = function(){
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2*Math.PI, false);
        if(this.type == 'bouncer'){
            ctx.strokeStyle=this.color;
            ctx.lineWidth=10;
            ctx.stroke();   
        } else {
            ctx.fillStyle=this.color;
            ctx.fill();
        }
        ctx.closePath();
    }
    
    this.update = function(){
        if(applyToHoles){
            this.y -= forceY;
        }
        if(this.y>innerHeight+(this.radius*2)){
            var multiplier = 120;
            if(this.type == 'dot'){
                this.radius = Math.random()*45;
            } else {
                this.radius = Math.random()*multiplier+30;
            }
            this.y = -(this.radius+10);
            this.x = Math.random() * innerWidth;
        }
        this.draw();
    }
}

function BestLine(y){
    this.y = y;
    this.draw = function(){
        ctx.beginPath();
        ctx.moveTo(0,this.y);
        ctx.lineTo(innerWidth,this.y);
        ctx.lineWidth = 5;
        ctx.strokeStyle = '#00000066';
        ctx.stroke();
        ctx.closePath();
    }

    this.update = function(){
        if(applyToHoles){
            this.y -= forceY;
        }
        this.draw();
    }

    this.setBest = function(b){
        this.y = b;
    }
}

function Block(x,y,w,h){
    this.x = x; this.y = y; this.w = w; this.h = h;
    this.draw = function(){
        ctx.fillStyle = '#FFF';
        ctx.fillRect(this.x, this.y, this.w, this.h);
    }

    this.update = function(){
        if(applyToHoles){
            this.y -= forceY;
        }

        if(this.y > innerHeight+this.h+30){
            this.h = Math.random()*80+20;
            this.w = Math.random()*(innerWidth/4);
            this.x = Math.random()*innerWidth;
            this.y = -(this.h+(Math.random()*20));
        }
        this.draw();
    }
}
    
var blocks = [];
for(var i = 0; i < 5; i++){
    blocks.push(new Block(Math.random()*innerWidth-50,Math.random()*innerHeight-(innerHeight/2),Math.random()*(innerWidth/3) + 40,Math.random()*100+30));
}

var holes = [];
for(var i = 0; i < 5; i++){
    holes.push(new Feature(Math.random()*innerWidth, Math.random()*innerHeight-innerHeight/2,Math.random()*120+30,'hole','#000'));
}

var bline = null;
    
var bouncers= [];
for(var i = 0; i < 4;i++){
    //bouncers.push(new Feature(Math.random()*innerWidth, Math.random()*innerHeight-innerHeight/2,Math.random()*50+20,'bouncer','#FFF'));
}
var marbles = [];
marbles.push(new Marble(innerWidth/2, innerHeight-150,20));


    
function animate(){
    window.requestAnimationFrame(animate);
    ctx.clearRect(0,0,innerWidth, innerHeight);
    
   

    for(var h = 0; h < holes.length;h++){
        holes[h].update();
    }
    
    for(var c = 0; c < bouncers.length;c++){
        bouncers[c].update();
    }

    for(var k = 0; k < blocks.length; k++){
        blocks[k].update();
    }
    
    for(var m = 0; m < marbles.length; m++){
        marbles[m].update(holes,bouncers,blocks);
    }

     scoredDist = Math.round(totalYforce)/100;
    displayScore = scoredDist;
    ctx.font = '50px sans-serif';
    ctx.fillText(displayScore+'m',20,100);
    
    if(gameOver){
        ctx.fillText('R to restart',20,160);
    }

    if(bestDistance > 0 && scoredDist < bestDistance){
        ctx.fillText(bestDistance, 20,160);
        if(bline == null){
            bline = new BestLine((innerHeight/2)-(bestDistance*100));
        } else {
            bline.update();
        }
    }
}

function Reset(){
    forceX = 0;
    forceY = 0;
    if(scoredDist > bestDistance){
        bestDistance = scoredDist;
    }
    bline = null;
    totalYforce = 0;
    displayScore = 0;
    scoredDist = 0;
    applyToHoles = false;

    holes = [];
    for(var i = 0; i < 10; i++){
        holes.push(new Feature(Math.random()*innerWidth, Math.random()*innerHeight-innerHeight/2,Math.random()*120+30,'hole','#000'));
    }

    bouncers = [];
    for(var i = 0; i < 4;i++){
        //bouncers.push(new Feature(Math.random()*innerWidth, Math.random()*innerHeight-innerHeight/2,Math.random()*50+20,'bouncer','#FFF'));
    }
    blocks = [];
    for(var k = 0; k < 5; k++){
         //blocks.push(new Block(Math.random()*innerWidth,Math.random()*innerHeight-innerHeight/2,Math.random()*(innerWidth/4),Math.random()*30));
    }
    marbles = [];
    marbles.push(new Marble(innerWidth/2, innerHeight-150,30));
    gameOver = false;
    canControl = true;
}

window.addEventListener('resize',function(){
    scaleCanvas();
});
    
window.addEventListener('deviceorientation', function(event){
    event.preventDefault();
    orient.a = event.alpha; //lean left and right
    orient.b = event.beta; //lean top to bottom
    orient.g = event.gamma; //rotation through center of screen.
    
    //we need alpha from -30(left) to 30(right)
    if(orient.a < -30.0){
        orient.a = -30.0;
    } else if(orient.a > 30){
        orient.a = 30;
    }
    //we need beta from -30(away) to 30(towards)
    if(orient.b < -30.0){
        orient.b = -30.0;
    } else if(orient.b > 30.0){
        orient.b = 30.0;
    }
    //Apply it... fingers crossed.
    forceX += (orient.g)/20;
    forceY += (orient.b)/20;
    
});

document.addEventListener('keydown',function(event){
    if(canControl){
        if(event.keyCode == 37){ //Left
            forceX-=0.2;
        } else if(event.keyCode == 39){ //Right
            forceX+=0.2;
        } 
        if(event.keyCode == 38){ //Up
            forceY-=0.2;

        } else if(event.keyCode ==40){ //Down
            forceY+=0.2;
            applyToHoles = false;
        }
    }
    if(event.keyCode == 82){
        Reset();
    }
})

document.addEventListener("touchend",function(evt){
    evt.preventDefault();
    var touches = evt.changedTouches;
    if(gameOver){
        if(touches.length>0){
            Reset();
        }
    } else {
        for(var m = 0; m < marbles.length; m++){
            marbles[m].jump();
        }
    }
});

function getDistance(x1,x2,y1,y2){
    return Math.sqrt(Math.pow(Math.abs(x1-x2),2)+Math.pow(Math.abs(y1-y2),2));
}

function RectCircleColliding(circle, rect){
    var ret = -1;
    var distX = Math.abs(circle.x-rect.x-rect.w/2);
    var distY = Math.abs(circle.y-rect.y-rect.h/2);

    if(distX > (rect.w/2+circle.radius)){
        return 0;
    }
     if (distY > (rect.h / 2 + circle.radius)) {
        return 0;
    }

    if (distX <= (rect.w / 2)) {
        console.log("DX");
        return 1;
    }
    if (distY <= (rect.h / 2)) {
        console.log("DY");
        return 2;
    }

    var dx = distX - rect.w / 2;
    var dy = distY - rect.h / 2;
    var pyth = (dx * dx + dy * dy <= (circle.r * circle.r));
        console.log("PYTH");
    return 3;
}

animate();
</script>
</body>
</html>